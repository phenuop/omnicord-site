<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Last Stand: Godroll</title>
<style>
  :root{
    --bg:#07080c;
    --panel:rgba(10,12,18,.72);
    --panel2:rgba(14,18,28,.86);
    --text:#e9eefc;
    --muted:#a9b3d6;

    --player:#45b8ff;        /* BLUE */
    --enemy:#ff3b5c;         /* RED */
    --gem:#2dff88;           /* GREEN */
    --power:#ffd166;         /* GOLD */
    --chest:#ff8a3d;         /* ORANGE */
    --bullet:#d9f2ff;        /* LIGHT */
    --enemyBullet:#b983ff;   /* PURPLE */

    --rare:#7aa2ff;
    --epic:#c77dff;
    --legend:#ff8a3d;
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--text)}
  #c{position:fixed;inset:0;width:100%;height:100%;display:block;background:radial-gradient(1200px 800px at 50% 40%, #0b1020 0%, #06070b 55%, #030308 100%);z-index:0}
  .ui{position:fixed;inset:0;pointer-events:none;z-index:5}
  .topbar{
    position:fixed;left:0;top:0;right:0;
    padding:10px 12px 10px 12px;
    background:linear-gradient(to bottom, rgba(0,0,0,.78), rgba(0,0,0,.06));
    pointer-events:none;
  }
  .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
  .pill{
    display:inline-flex;gap:8px;align-items:center;
    background:var(--panel); border:1px solid rgba(255,255,255,.08);
    border-radius:999px; padding:6px 10px; box-shadow:0 8px 24px rgba(0,0,0,.35);
    font-size:12px; color:var(--text); letter-spacing:.2px;
  }
  .pill b{font-weight:900}
  .muted{color:var(--muted)}
  .xpwrap{
    margin-top:8px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px; overflow:hidden;
    box-shadow:0 10px 28px rgba(0,0,0,.38);
    height:16px;
    position:relative;
  }
  .xpfill{
    height:100%;
    background:linear-gradient(90deg, rgba(45,255,136,.25), rgba(45,255,136,.92));
    box-shadow:0 0 18px rgba(45,255,136,.45);
    width:0%;
  }
  .xptext{
    position:absolute;left:12px;top:44px;font-size:12px;
    text-shadow:0 2px 10px rgba(0,0,0,.85);
    pointer-events:none;
  }
  .hint{
    position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
    background:var(--panel);
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:10px 12px;
    max-width:min(820px, calc(100% - 24px));
    box-shadow:0 12px 32px rgba(0,0,0,.45);
    font-size:13px;color:var(--text);
    opacity:0; transition:opacity .25s ease;
    pointer-events:none;
  }
  .hint.show{opacity:1}
  .hint kbd{
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;
    background:rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.14);
    border-bottom-color:rgba(0,0,0,.35);
    padding:2px 6px;border-radius:8px;
    margin:0 2px;
  }

  .menu, .overlay{
    position:fixed;inset:0;
    display:flex;align-items:center;justify-content:center;
    background:radial-gradient(900px 600px at 50% 38%, rgba(15,20,35,.75) 0%, rgba(0,0,0,.88) 70%, rgba(0,0,0,.95) 100%);
    pointer-events:auto;
    z-index:10;
  }
  .card{
    width:min(1040px, calc(100% - 24px));
    border-radius:18px;
    background:var(--panel2);
    border:1px solid rgba(255,255,255,.10);
    box-shadow:0 22px 60px rgba(0,0,0,.65);
    padding:18px;
  }
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:14px}
  @media (max-width:900px){ .grid{grid-template-columns:1fr;}}
  h1{margin:0 0 6px 0;font-size:26px;letter-spacing:.4px}
  .subtitle{margin:0 0 14px 0;color:var(--muted);font-size:13px;line-height:1.35}
  .panel{
    background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    padding:14px;
  }
  .btnrow{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
  button{
    pointer-events:auto;
    appearance:none;border:none;cursor:pointer;
    color:var(--text);
    background:linear-gradient(180deg, rgba(69,184,255,.20), rgba(69,184,255,.05));
    border:1px solid rgba(69,184,255,.35);
    border-radius:14px;
    padding:10px 12px;
    font-weight:900;
    letter-spacing:.2px;
    box-shadow:0 14px 32px rgba(0,0,0,.35);
    transition:transform .07s ease, filter .15s ease, box-shadow .15s ease;
  }
  button:hover{filter:brightness(1.08)}
  button:active{transform:translateY(1px);box-shadow:0 10px 22px rgba(0,0,0,.35)}
  button:disabled{opacity:.55;cursor:not-allowed;filter:saturate(.7)}
  .btnAlt{
    background:linear-gradient(180deg, rgba(255,209,102,.18), rgba(255,209,102,.05));
    border-color:rgba(255,209,102,.32);
  }
  .btnDanger{
    background:linear-gradient(180deg, rgba(255,59,92,.18), rgba(255,59,92,.05));
    border-color:rgba(255,59,92,.32);
  }
  .field{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
  label{font-size:12px;color:var(--muted)}
  input, select{
    pointer-events:auto;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.14);
    color:var(--text);
    border-radius:12px;
    padding:10px 10px;
    outline:none;
  }
  input{width:170px}
  .small{font-size:12px;color:var(--muted);line-height:1.4}

  /* ALTAR */
  .altar{
    position:fixed;inset:0;
    display:none;align-items:center;justify-content:center;
    background:radial-gradient(800px 520px at 50% 42%, rgba(15,20,35,.62) 0%, rgba(0,0,0,.80) 70%, rgba(0,0,0,.92) 100%);
    pointer-events:auto;
    z-index:20;
  }
  .altar.show{display:flex}
  .altarWrap{
    width:min(1120px, calc(100% - 24px));
    background:var(--panel2);
    border:1px solid rgba(255,255,255,.12);
    border-radius:20px;
    box-shadow:0 28px 80px rgba(0,0,0,.75);
    padding:16px;
  }
  .altarHead{display:flex;justify-content:space-between;align-items:flex-end;gap:10px;margin-bottom:12px}
  .altarHead h2{margin:0;font-size:18px;letter-spacing:.3px}
  .cards{display:grid;grid-template-columns:repeat(3, 1fr);gap:12px}
  @media (max-width:980px){ .cards{grid-template-columns:1fr;}}
  .pick{
    cursor:pointer; user-select:none;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.10));
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    padding:14px;
    box-shadow:0 18px 46px rgba(0,0,0,.55);
    transition:transform .08s ease, filter .15s ease, border-color .15s ease;
    position:relative;
    overflow:hidden;
  }
  .pick:hover{transform:translateY(-1px);filter:brightness(1.06)}
  .pick:active{transform:translateY(0px)}
  .pick .title{display:flex;justify-content:space-between;gap:10px;align-items:center}
  .pick .type{
    font-weight:950; letter-spacing:.6px; font-size:12px;
    padding:4px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.22);
  }
  .pick .k{font-size:12px;color:var(--muted)}
  .pick .name{font-size:18px;font-weight:950;margin-top:8px}
  .pick .desc{margin-top:6px;font-size:13px;color:var(--text);line-height:1.35}
  .pick .odds{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35}
  .pick .hotkey{
    position:absolute;right:12px;top:12px;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;
    background:rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.16);
    padding:3px 7px;border-radius:10px;
  }
  .safeGlow{border-color:rgba(45,255,136,.30)}
  .gambleGlow{border-color:rgba(255,209,102,.28)}
  .chaosGlow{border-color:rgba(199,125,255,.28)}
  .stripe{
    position:absolute;inset:auto -30px 14px auto;
    transform:rotate(18deg);
    font-size:11px;font-weight:950;letter-spacing:.4px;
    padding:6px 40px;
    background:rgba(122,162,255,.16);
    border:1px solid rgba(122,162,255,.32);
    color:var(--rare);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="topbar">
    <div class="row">
      <div class="pill"><b>LAST STAND: GODROLL</b> <span class="muted" id="seedTag"></span></div>
      <div class="row" style="gap:8px;justify-content:flex-end;flex-wrap:wrap">
        <div class="pill"><span class="muted">Time</span> <b id="hudTime">0:00</b></div>
        <div class="pill"><span class="muted">Lvl</span> <b id="hudLvl">1</b></div>
        <div class="pill"><span class="muted">HP</span> <b id="hudHP">10</b></div>
        <div class="pill"><span class="muted">Shards</span> <b id="hudShards">0</b></div>
        <div class="pill"><span class="muted">DPS</span> <b id="hudDPS">0</b></div>
        <div class="pill"><span class="muted">Streak</span> <b id="hudStreak">x1.0</b></div>
        <div class="pill"><span class="muted">Corrupt</span> <b id="hudCorr">0</b></div>
        <div class="pill"><span class="muted">Mute</span> <b id="hudMute">OFF</b></div>
      </div>
    </div>

    <div class="xpwrap" aria-label="XP progress">
      <div class="xpfill" id="xpFill"></div>
    </div>
    <div class="xptext" id="xpText">XP 0 / 10</div>
  </div>

  <div class="hint" id="hint"></div>
</div>

<!-- MENUS -->
<div class="menu" id="menu">
  <div class="card">
    <div class="grid">
      <div class="panel">
        <h1>last stand: godroll</h1>
        <p class="subtitle">Simple loop: <b>kill</b> → grab <b>green XP</b> → level → pick a card → snowball. Blue = you. Red = enemies. Gold = powerups.</p>

        <div class="field">
          <label for="seedIn">Seed</label>
          <input id="seedIn" placeholder="(blank = random)" />
        </div>

        <div class="field">
          <label for="charSel">Character</label>
          <select id="charSel"></select>
          <span class="small" id="charDesc">—</span>
        </div>

        <div class="btnrow">
          <button id="startBtn">Start Run</button>
          <button class="btnAlt" id="shopBtn">Meta Upgrades</button>
          <button class="btnDanger" id="wipeBtn">Wipe Save</button>
          <button id="muteBtn">Toggle Mute (M)</button>
        </div>

        <p class="small" style="margin-top:10px">
          Controls: <b>WASD</b> move, <b>Space</b> dash, <b>ESC</b> pause, <b>1/2/3</b> pick cards, <b>M</b> mute.
        </p>
      </div>

      <div class="panel">
        <h2 style="margin:0 0 6px 0;font-size:16px">Meta Progress</h2>
        <p class="small" style="margin:0 0 10px 0">
          Spend shards to unlock more chaos/gamble variety + characters. Saved to localStorage.
        </p>
        <div class="row" style="gap:10px;justify-content:flex-start;flex-wrap:wrap">
          <div class="pill"><span class="muted">Total Shards</span> <b id="metaShards">0</b></div>
          <div class="pill"><span class="muted">Risk Ceiling</span> <b id="riskCeilTag">0</b></div>
        </div>
        <div class="small" style="margin-top:10px">
          <b>CHAOS</b> gives power but adds <b>corruption</b> (harder enemy ramp).
        </div>
      </div>
    </div>
  </div>
</div>

<!-- SHOP -->
<div class="overlay" id="shop" style="display:none">
  <div class="card">
    <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
      <div>
        <h2 style="margin:0;font-size:18px">meta upgrades</h2>
        <div class="small" style="margin-top:6px">Unlock crazier altar content + characters. Saved to localStorage.</div>
      </div>
      <div class="pill"><span class="muted">Shards</span> <b id="shopShards">0</b></div>
    </div>

    <div id="shopList" style="margin-top:12px;display:flex;flex-direction:column;gap:10px"></div>

    <div class="btnrow" style="margin-top:12px">
      <button id="shopBackBtn">Back</button>
    </div>
  </div>
</div>

<!-- ALTAR (also used for CHEST) -->
<div class="altar" id="altar">
  <div class="altarWrap">
    <div class="altarHead">
      <div>
        <h2 id="altarTitle">ALTAR OF RISK</h2>
        <p class="small" style="margin:6px 0 0 0" id="altarSub">Pick <b>SAFE</b>, <b>GAMBLE</b>, or <b>CHAOS</b>. (Keys: 1 / 2 / 3)</p>
      </div>
      <div class="small" style="text-align:right">
        <div><span class="muted">Near-miss:</span> <span id="nearMiss">—</span></div>
        <div><span class="muted">Luck:</span> <span id="luckTag">0%</span></div>
      </div>
    </div>
    <div class="cards" id="cards"></div>
  </div>
</div>

<!-- DEATH -->
<div class="overlay" id="death" style="display:none">
  <div class="card">
    <h2 style="margin:0;font-size:20px">you died.</h2>
    <div class="small" style="margin-top:6px" id="deathStats">—</div>
    <div class="panel" style="margin-top:12px">
      <div style="font-weight:950;letter-spacing:.3px">final stats</div>
      <div class="small" style="margin-top:6px" id="deathBuild">—</div>
    </div>
    <div class="btnrow" style="margin-top:12px">
      <button id="deathMenuBtn">Main Menu</button>
      <button class="btnAlt" id="deathRetryBtn">Run It Back</button>
    </div>
  </div>
</div>

<script>
(() => {
"use strict";

/* ============================
   VISUAL CLARITY SETTINGS
============================ */
const ZOOM_BASE = 1.55;         // more zoomed-in
const SIZE_MULT = 1.25;         // bigger entities
const DAMAGE_FLOAT_CHANCE = 0.85; // show lots of damage numbers

/* ============================
   RNG
============================ */
function hashStringToSeed(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h>>>0;
}
function mulberry32(seed){
  return function(){
    let t = (seed += 0x6D2B79F5)>>>0;
    t = Math.imul(t ^ (t>>>15), t|1);
    t ^= t + Math.imul(t ^ (t>>>7), t|61);
    return ((t ^ (t>>>14))>>>0)/4294967296;
  };
}
class RNG{
  constructor(seedStr){
    const s = seedStr && seedStr.trim().length ? seedStr.trim() : (""+Math.floor(Math.random()*1e9));
    this.seedStr=s; this.seed=hashStringToSeed(s)>>>0; this.r=mulberry32(this.seed);
  }
  f(){ return this.r(); }
  i(n){ return (this.f()*n)|0; }
  pick(a){ return a[this.i(a.length)]; }
  chance(p){ return this.f()<p; }
  range(a,b){ return a+(b-a)*this.f(); }
  weighted(items){
    let sum=0; for(let i=0;i<items.length;i++) sum+=items[i].w;
    let t=this.f()*sum;
    for(let i=0;i<items.length;i++){ t-=items[i].w; if(t<=0) return items[i].v; }
    return items[items.length-1].v;
  }
}

/* ============================
   Canvas / DPR
============================ */
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d",{alpha:true,desynchronized:true});
let W=1,H=1,DPR=1;
function resize(){
  DPR=Math.max(1, Math.min(2.25, window.devicePixelRatio||1));
  const cssW=Math.max(320, window.innerWidth|0);
  const cssH=Math.max(240, window.innerHeight|0);
  canvas.style.width=cssW+"px"; canvas.style.height=cssH+"px";
  canvas.width=(cssW*DPR)|0; canvas.height=(cssH*DPR)|0;
  W=canvas.width; H=canvas.height;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled=false;
}
window.addEventListener("resize", resize);

/* ============================
   Audio (subtle)
============================ */
class AudioSys{
  constructor(){ this.ctx=null; this.master=null; this.muted=false; this.ready=false; }
  ensure(){
    if(this.ready) return;
    const AC=window.AudioContext||window.webkitAudioContext;
    if(!AC) return;
    this.ctx=new AC();
    this.master=this.ctx.createGain();
    this.master.gain.value=0.30;
    this.master.connect(this.ctx.destination);
    this.ready=true;
  }
  setMute(m){ this.muted=m; if(this.master) this.master.gain.value=m?0:0.30; }
  beep({type="sine",freq=440,dur=0.08,gain=0.10,detune=0,slide=0,noise=false}){
    if(!this.ready||this.muted) return;
    const t0=this.ctx.currentTime;
    const g=this.ctx.createGain();
    g.gain.setValueAtTime(0.0001,t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002,gain),t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
    g.connect(this.master);
    if(noise){
      const buf=this.ctx.createBuffer(1,2048,this.ctx.sampleRate);
      const d=buf.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.55;
      const src=this.ctx.createBufferSource(); src.buffer=buf;
      const f=this.ctx.createBiquadFilter(); f.type="lowpass"; f.frequency.setValueAtTime(freq,t0);
      src.connect(f); f.connect(g);
      src.start(t0); src.stop(t0+dur);
      return;
    }
    const o=this.ctx.createOscillator();
    o.type=type; o.detune.value=detune;
    o.frequency.setValueAtTime(freq,t0);
    if(slide!==0) o.frequency.exponentialRampToValueAtTime(Math.max(20,freq*(1+slide)), t0+dur);
    o.connect(g); o.start(t0); o.stop(t0+dur);
  }
  s_pick(){ this.beep({type:"triangle",freq:740,dur:0.06,gain:0.07,slide:0.35}); }
  s_lvl(){ this.beep({type:"sine",freq:520,dur:0.12,gain:0.11,slide:0.60}); this.beep({type:"sine",freq:820,dur:0.14,gain:0.09}); }
  s_click(){ this.beep({type:"square",freq:240,dur:0.05,gain:0.07,detune:-5}); }
  s_crit(){ this.beep({type:"sawtooth",freq:360,dur:0.08,gain:0.12,slide:0.9}); }
  s_explo(){ this.beep({noise:true,freq:420,dur:0.09,gain:0.14}); }
  s_dash(){ this.beep({type:"triangle",freq:260,dur:0.08,gain:0.09,slide:-0.35}); }
  s_boss(){ this.beep({type:"sine",freq:90,dur:0.38,gain:0.14}); }
  s_hurt(){ this.beep({type:"square",freq:180,dur:0.06,gain:0.10,slide:-0.2}); }
  s_power(){ this.beep({type:"triangle",freq:980,dur:0.06,gain:0.08,slide:0.35}); }
  s_chest(){ this.beep({type:"sine",freq:320,dur:0.12,gain:0.12,slide:0.7}); this.beep({type:"triangle",freq:560,dur:0.16,gain:0.10}); }
}
const audio=new AudioSys();

/* ============================
   Pools
============================ */
function makePool(factory, initial){
  const arr=[]; for (let i=0;i<initial;i++) arr.push(factory());
  return { arr,
    get(){ return arr.length?arr.pop():factory(); },
    free(o){ arr.push(o); }
  };
}

/* ============================
   Spatial grid
============================ */
class Grid{
  constructor(cell){ this.cell=cell; this.map=new Map(); }
  clear(){ this.map.clear(); }
  key(cx,cy){ return (cx<<16) ^ (cy & 0xffff); }
  insert(kind, idx, x,y){
    const cx=(x/this.cell)|0, cy=(y/this.cell)|0;
    const k=this.key(cx,cy);
    let b=this.map.get(k);
    if(!b){ b={b:[],e:[],g:[],d:[]}; this.map.set(k,b); }
    b[kind].push(idx);
  }
  query(x,y,out){
    out.length=0;
    const cx=(x/this.cell)|0, cy=(y/this.cell)|0;
    for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++) out.push(this.key(cx+ox, cy+oy));
    return out;
  }
}

/* ============================
   DOM
============================ */
const ui={
  menu:document.getElementById("menu"),
  shop:document.getElementById("shop"),
  death:document.getElementById("death"),
  altar:document.getElementById("altar"),
  cards:document.getElementById("cards"),
  altarTitle:document.getElementById("altarTitle"),
  altarSub:document.getElementById("altarSub"),
  nearMiss:document.getElementById("nearMiss"),
  luckTag:document.getElementById("luckTag"),
  hint:document.getElementById("hint"),
  seedTag:document.getElementById("seedTag"),

  hudTime:document.getElementById("hudTime"),
  hudLvl:document.getElementById("hudLvl"),
  hudHP:document.getElementById("hudHP"),
  hudShards:document.getElementById("hudShards"),
  hudDPS:document.getElementById("hudDPS"),
  hudStreak:document.getElementById("hudStreak"),
  hudCorr:document.getElementById("hudCorr"),
  hudMute:document.getElementById("hudMute"),

  xpFill:document.getElementById("xpFill"),
  xpText:document.getElementById("xpText"),

  metaShards:document.getElementById("metaShards"),
  riskCeilTag:document.getElementById("riskCeilTag"),
  shopShards:document.getElementById("shopShards"),
  shopList:document.getElementById("shopList"),

  deathStats:document.getElementById("deathStats"),
  deathBuild:document.getElementById("deathBuild"),

  seedIn:document.getElementById("seedIn"),
  charSel:document.getElementById("charSel"),
  charDesc:document.getElementById("charDesc"),
};

/* ============================
   Meta save
============================ */
const META_KEY="ls_godroll_meta_v5";
const defaultMeta=()=>({ shards:0, unlocks:{riskCeiling:0, chaosPlus:0, gamblePlus:0, chars:1}, discovered:{} });
let meta=loadMeta();
function loadMeta(){
  try{
    const raw=localStorage.getItem(META_KEY);
    if(!raw) return defaultMeta();
    const m=JSON.parse(raw);
    const d=defaultMeta();
    if(typeof m.shards==="number") d.shards=m.shards;
    if(m.unlocks) d.unlocks=Object.assign(d.unlocks, m.unlocks);
    if(m.discovered) d.discovered=m.discovered;
    return d;
  }catch(e){ return defaultMeta(); }
}
function saveMeta(){
  try{ localStorage.setItem(META_KEY, JSON.stringify(meta)); }catch(e){}
  ui.metaShards.textContent=meta.shards|0;
  ui.shopShards.textContent=meta.shards|0;
  ui.riskCeilTag.textContent=meta.unlocks.riskCeiling|0;
}

/* ============================
   Helpers
============================ */
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const len2=(x,y)=>x*x+y*y;
const norm=(x,y)=>{ const d=Math.hypot(x,y)||1; return [x/d,y/d]; };

/* ============================
   Entities + pools
============================ */
const bullets=[], enemies=[], particles=[], floats=[], gems=[], drops=[];
const MAX_BULLETS=1500, MAX_ENEMIES=900, MAX_PARTS=1200, MAX_FLOATS=360, MAX_GEMS=600, MAX_DROPS=120;

const bulletPool=makePool(()=>({active:false,x:0,y:0,vx:0,vy:0,r:2,dmg:1,life:0,pierce:0,bounce:0,fromPlayer:true,crit:false,color:"#fff",trail:0}), 1000);
const enemyPool =makePool(()=>({active:false,type:0,x:0,y:0,vx:0,vy:0,r:10,hp:3,maxhp:3,spd:18,dmg:1,cd:0,elite:false,mod:0,tint:"#f00",outline:"rgba(0,0,0,.72)", boss:false, showDmgT:0}), 800);
const partPool  =makePool(()=>({active:false,x:0,y:0,vx:0,vy:0,life:0,max:0,r:1,col:"#fff",a:1}), 1400);
const floatPool =makePool(()=>({active:false,x:0,y:0,vy:0,life:0,max:0,text:"",col:"#fff",big:false}), 420);
const gemPool   =makePool(()=>({active:false,x:0,y:0,vx:0,vy:0,r:6,val:1,rare:0}), 620);
const dropPool  =makePool(()=>({active:false,x:0,y:0,vx:0,vy:0,r:10,kind:0,t:0}), 180);

/* ============================
   Game state
============================ */
const COLORS={
  player:getCSS("--player"),
  enemy:getCSS("--enemy"),
  gem:getCSS("--gem"),
  power:getCSS("--power"),
  chest:getCSS("--chest"),
  bullet:getCSS("--bullet"),
  enemyBullet:getCSS("--enemyBullet"),
  rare:getCSS("--rare"),
  epic:getCSS("--epic"),
  legend:getCSS("--legend"),
};
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

const player={
  x:0,y:0,vx:0,vy:0,r:12,
  hp:10,maxhp:10,
  iFrames:0,
  lvl:1,xp:0,xpNeed:12,
  shardsRun:0,
  dmg:1, atkSpd:1, projSpd:1, range:1, move:1,
  crit:0.05, critDmg:1.8,
  armor:0, luck:0,
  magnet:0,
  upgrades:{},
  dashCd:0, dashMax:3.2, dashing:0,
  corr:0,
  baseDmg:1, baseAtk:1, baseCrit:0.05, baseCritD:1.8,
  baseMove:1, baseLuck:0, baseMagnet:0,
};

const cam={x:0,y:0,shake:0,sx:0,sy:0,slow:0};
const grid=new Grid(92);
const tmpKeys=[];

let rng=new RNG("");
let runSeed="";
let state="MENU"; // MENU, RUN, ALTAR, PAUSE, DEATH
let altarMode="ALTAR"; // ALTAR or CHEST
let tRun=0;
let spawnAcc=0;
let doomSpawned=false;

/* ============================
   Streak (XP tempo)
============================ */
let streak=1.0, streakMeter=0, streakTimer=0;
let streakCap=2.4, streakDecay=1.0, streakGain=0.18;

/* ============================
   Corruption (CHAOS cost)
============================ */
function corrMult(){
  const c=player.corr|0;
  return 1 + c*0.10;
}
function corrDropBonus(){
  const c=player.corr|0;
  return Math.min(0.20, c*0.03);
}

/* ============================
   Input
============================ */
const keys=new Set();
let mouseX=0, mouseY=0, mouseDown=false;

window.addEventListener("keydown",(e)=>{
  if(e.repeat) return;
  keys.add(e.code);

  if((state==="ALTAR") && (e.code==="Digit1"||e.code==="Digit2"||e.code==="Digit3")) e.preventDefault();

  if(e.code==="KeyM") toggleMute();
  if(e.code==="Escape"){
    if(state==="RUN") pauseToggle();
    else if(state==="PAUSE") pauseToggle();
  }
  if(state==="ALTAR"){
    if(e.code==="Digit1") pickCard(0);
    if(e.code==="Digit2") pickCard(1);
    if(e.code==="Digit3") pickCard(2);
  }
});
window.addEventListener("keyup",(e)=> keys.delete(e.code));
window.addEventListener("mousemove",(e)=>{
  const rect=canvas.getBoundingClientRect();
  mouseX=(e.clientX-rect.left)*DPR;
  mouseY=(e.clientY-rect.top)*DPR;
});
window.addEventListener("mousedown",()=>{ mouseDown=true; audio.ensure(); });
window.addEventListener("mouseup",()=> mouseDown=false);
window.addEventListener("blur",()=>{
  if(state==="RUN"){ state="PAUSE"; showHint("Paused (tabbed out). Press <kbd>ESC</kbd> to resume.", 1); }
});

/* ============================
   Buttons
============================ */
document.getElementById("startBtn").addEventListener("click",()=>{ audio.ensure(); startFromMenu(); });
document.getElementById("shopBtn").addEventListener("click",()=>{ audio.ensure(); openShop(); });
document.getElementById("shopBackBtn").addEventListener("click",()=>{ audio.ensure(); closeShop(); });
document.getElementById("deathMenuBtn").addEventListener("click",()=>{ audio.ensure(); goMenu(); });
document.getElementById("deathRetryBtn").addEventListener("click",()=>{ audio.ensure(); startFromMenu(true); });
document.getElementById("wipeBtn").addEventListener("click",()=>{
  audio.ensure(); audio.s_click();
  localStorage.removeItem(META_KEY);
  meta=defaultMeta(); saveMeta();
  refreshCharacterList();
  showHint("Save wiped.",1.4);
});
document.getElementById("muteBtn").addEventListener("click",()=>{ audio.ensure(); toggleMute(); });

/* ============================
   Shop / Characters
============================ */
const characters=[
  {id:"drifter", name:"drifter", desc:"+10% move. starts with pebble I.", apply:()=>{ player.move*=1.10; } },
  {id:"zealot", name:"zealot", desc:"+12% damage. -6% move.", apply:()=>{ player.dmg*=1.12; player.move*=0.94; } },
  {id:"gambler", name:"gambler", desc:"+10% luck. -1 max HP.", apply:()=>{ player.luck+=0.10; player.maxhp=Math.max(1,player.maxhp-1); player.hp=Math.min(player.hp,player.maxhp);} },
];
function refreshCharacterList(){
  ui.charSel.innerHTML="";
  const unlocked=clamp(meta.unlocks.chars|0,1,3);
  for(let i=0;i<unlocked;i++){
    const c=characters[i];
    const opt=document.createElement("option");
    opt.value=c.id; opt.textContent=c.name;
    ui.charSel.appendChild(opt);
  }
  const pick=characters.find(c=>c.id===ui.charSel.value)||characters[0];
  ui.charDesc.textContent=pick.desc;
}
ui.charSel.addEventListener("change",()=>{
  const pick=characters.find(c=>c.id===ui.charSel.value)||characters[0];
  ui.charDesc.textContent=pick.desc;
});

const shopItems=[
  {key:"riskCeiling", name:"risk ceiling", desc:"bigger gamble/chaos swings.", base:20, step:18, max:5, buy:()=>meta.unlocks.riskCeiling++},
  {key:"chaosPlus", name:"chaos vault", desc:"more chaos mutations.", base:18, step:14, max:6, buy:()=>meta.unlocks.chaosPlus++},
  {key:"gamblePlus", name:"loaded altar", desc:"more gamble effects.", base:14, step:12, max:6, buy:()=>meta.unlocks.gamblePlus++},
  {key:"chars", name:"new challenger", desc:"unlock a new character.", base:30, step:999, max:3, buy:()=>meta.unlocks.chars++},
];
function renderShop(){
  ui.shopShards.textContent=meta.shards|0;
  ui.shopList.innerHTML="";
  for(const it of shopItems){
    const lvl=meta.unlocks[it.key]|0;
    const cost=(lvl>=it.max)?null:(it.base+it.step*lvl);
    const row=document.createElement("div");
    row.style.display="flex";
    row.style.justifyContent="space-between";
    row.style.gap="10px";
    row.style.alignItems="center";
    row.style.background="rgba(0,0,0,.25)";
    row.style.border="1px solid rgba(255,255,255,.10)";
    row.style.borderRadius="14px";
    row.style.padding="10px 10px";
    const left=document.createElement("div");
    left.innerHTML=`<div style="font-weight:950">${it.name} <span class="muted">(${lvl}/${it.max})</span></div><div class="small" style="margin-top:2px">${it.desc}</div>`;
    const right=document.createElement("div");
    if(cost===null){
      right.innerHTML=`<span class="small">maxed</span>`;
    }else{
      const btn=document.createElement("button");
      btn.textContent=`buy (${cost})`;
      btn.disabled=meta.shards<cost;
      btn.addEventListener("click",()=>{
        audio.ensure(); audio.s_click();
        if(meta.shards<cost) return;
        meta.shards-=cost; it.buy();
        saveMeta(); renderShop(); refreshCharacterList();
      });
      right.appendChild(btn);
    }
    row.appendChild(left); row.appendChild(right);
    ui.shopList.appendChild(row);
  }
}
function openShop(){ ui.menu.style.display="none"; ui.shop.style.display="flex"; renderShop(); }
function closeShop(){ ui.shop.style.display="none"; ui.menu.style.display="flex"; saveMeta(); }

/* ============================
   FX Helpers
============================ */
function addShake(s){ cam.shake=Math.min(18, cam.shake+s); }
function particle(x,y,vx,vy,life,r,col,a=1){
  if(particles.length>=MAX_PARTS) return;
  const p=partPool.get();
  p.active=true; p.x=x; p.y=y; p.vx=vx; p.vy=vy; p.life=life; p.max=life; p.r=r; p.col=col; p.a=a;
  particles.push(p);
}
function burst(x,y,n,spd,col,rMin,rMax,lifeMin,lifeMax){
  const budget=Math.max(0, MAX_PARTS - particles.length);
  n=Math.min(n, budget);
  for(let i=0;i<n;i++){
    const a=rng.f()*Math.PI*2;
    const s=spd*(0.35+rng.f()*0.65);
    particle(x,y,Math.cos(a)*s,Math.sin(a)*s, lifeMin+rng.f()*(lifeMax-lifeMin), rMin+rng.f()*(rMax-rMin), col,1);
  }
}
function floatText(x,y,text,col,big=false){
  if(floats.length>=MAX_FLOATS) return;
  const f=floatPool.get();
  f.active=true; f.x=x; f.y=y; f.vy=-22-(big?18:0); f.life=big?0.9:0.72; f.max=f.life; f.text=text; f.col=col; f.big=big;
  floats.push(f);
}

/* ============================
   Drops (powerups + chest)
============================ */
const DROP={MAGNET:0, FOOD:1, FRENZY:2, DOUBLE:3, NUKE:4, CHEST:5};
function spawnDrop(x,y,kind){
  if(drops.length>=MAX_DROPS) return;
  const d=dropPool.get();
  d.active=true; d.x=x; d.y=y; d.vx=(rng.f()*2-1)*40; d.vy=(rng.f()*2-1)*40; d.r=12*DPR*SIZE_MULT; d.kind=kind; d.t=0;
  drops.push(d);
}
let buffFrenzy=0;
let buffDouble=0;
let magnetAll=0;

function applyDrop(kind){
  if(kind===DROP.MAGNET){
    magnetAll=1.2; audio.s_power();
    floatText(player.x, player.y-46, "MAGNET!", COLORS.gem, true); addShake(10);
  }else if(kind===DROP.FOOD){
    const heal=Math.max(2, Math.floor(player.maxhp*0.18));
    player.hp=Math.min(player.maxhp, player.hp+heal);
    audio.s_power();
    floatText(player.x, player.y-46, `+${heal} HP`, COLORS.gem, true);
  }else if(kind===DROP.FRENZY){
    buffFrenzy=8.0; audio.s_power();
    floatText(player.x, player.y-46, "FRENZY!", COLORS.power, true); addShake(8);
  }else if(kind===DROP.DOUBLE){
    buffDouble=6.0; audio.s_power();
    floatText(player.x, player.y-46, "x2 DMG!", COLORS.chest, true); addShake(10);
  }else if(kind===DROP.NUKE){
    audio.s_explo();
    floatText(player.x, player.y-56, "NUKE!", COLORS.enemy, true); addShake(16);
    const rad=520*DPR, rad2=rad*rad;
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; if(!e.active) continue;
      if(len2(e.x-player.x, e.y-player.y)<=rad2){
        e.hp=0; e.active=false;
        spawnGem(e.x,e.y, 2+(e.elite?2:0), e.elite?2:0);
      }
    }
    burst(player.x,player.y, 120, 520, "rgba(255,59,92,.55)", 1.2*DPR, 4.2*DPR, 0.12, 0.55);
  }else if(kind===DROP.CHEST){
    audio.s_chest(); addShake(14);
    floatText(player.x, player.y-56, "CHEST!", COLORS.chest, true);
    openChest();
  }
}

/* ============================
   Gems
============================ */
function spawnGem(x,y,val,rare){
  if(gems.length>=MAX_GEMS) return;
  const g=gemPool.get();
  g.active=true; g.x=x; g.y=y; g.vx=(rng.f()*2-1)*18; g.vy=(rng.f()*2-1)*18; g.r=6*DPR*SIZE_MULT; g.val=val; g.rare=rare;
  gems.push(g);
}

/* ============================
   Enemy types + clarity
============================ */
const ENEMY={SWARM:0,RUNNER:1,TANK:2,SPITTER:3,SPLITTER:4,ELITE:5,BOSS:6};
function enemyStyle(e){
  // All enemies are RED family, but shapes + size make them obvious.
  if(e.type===ENEMY.RUNNER) e.tint="#ff6b3b";         // orange-red fast
  else if(e.type===ENEMY.TANK) e.tint="#ff2fc6";      // pink heavy
  else if(e.type===ENEMY.SPITTER) e.tint="#ff3b5c";   // red spitter
  else if(e.type===ENEMY.SPLITTER) e.tint="#ff3b5c";  // red splitter
  else if(e.type===ENEMY.ELITE) e.tint="#fff2f6";     // pale elite
  else if(e.type===ENEMY.BOSS) e.tint="#b983ff";      // purple boss
  else e.tint=COLORS.enemy;
  e.outline="rgba(0,0,0,.78)";
}

/* ============================
   Scaling + spawn rate
============================ */
function spawnRatePerSec(t){
  const t0=Math.max(0, t-12);
  const corr=corrMult();
  const rate = 0.10 * Math.exp(t0/55) * corr;
  return Math.min(48, rate);
}
function hpScale(t){ return (1 + (t/120)*0.18 + (t/420)*0.22) * corrMult(); }
function spdScale(t){ return (1 + (t/180)*0.10 + (t/700)*0.08) * (1 + (player.corr|0)*0.02); }

/* ============================
   Weapons (simple descriptions)
============================ */
const weaponDefs=[
  {key:"pebble", name:"pebble", color:COLORS.bullet, max:8, short:"fast shots",
    fire:(dt)=>{
      const lvl=player.upgrades.pebble|0;
      const cdBase=0.58 * Math.pow(0.92, lvl-1);
      weaponCD("pebble", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=560*player.projSpd*(1+0.06*(lvl-1));
        const dmg=1.0*player.dmg*(1+0.12*(lvl-1));
        spawnBullet(player.x,player.y, dx*sp,dy*sp, 3.4*DPR*SIZE_MULT, dmg, 1.15, COLORS.bullet, 0,0, rollCrit(), 0.75, true);
      });
    }
  },
  {key:"knife", name:"knife fan", color:COLORS.power, max:8, short:"spread",
    fire:(dt)=>{
      const lvl=player.upgrades.knife|0;
      const cdBase=0.34 * Math.pow(0.92, lvl-1);
      weaponCD("knife", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=760*player.projSpd;
        const shots=1 + Math.min(8, (player.upgrades.multi||0)) + Math.floor((lvl-1)/2);
        const spread=0.20 * Math.pow(0.85, lvl-1);
        const base=0.62*player.dmg*(1+0.08*(lvl-1));
        for(let i=0;i<shots;i++){
          const a=(i-(shots-1)/2)*spread;
          const ca=Math.cos(a), sa=Math.sin(a);
          const vx=(dx*ca-dy*sa)*sp, vy=(dx*sa+dy*ca)*sp;
          spawnBullet(player.x,player.y, vx,vy, 2.7*DPR*SIZE_MULT, base, 0.78, COLORS.power, 0,0, rollCrit(0.85), 0.9, true);
        }
      });
    }
  },
  {key:"axe", name:"whirl axe", color:COLORS.epic, max:8, short:"big cleave",
    fire:(dt)=>{
      const lvl=player.upgrades.axe|0;
      const cdBase=1.05 * Math.pow(0.92, lvl-1);
      weaponCD("axe", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=360*player.projSpd;
        const dmg=1.55*player.dmg*(1+0.10*(lvl-1));
        const r=(8.6 + 1.0*(lvl-1))*DPR*SIZE_MULT;
        const pier=1 + Math.floor((lvl-1)/2) + (player.upgrades.pierce||0);
        spawnBullet(player.x,player.y, dx*sp,dy*sp, r, dmg, 1.4, COLORS.epic, pier,0, rollCrit(1.0), 0.0, true);
      });
    }
  },
  {key:"spark", name:"spark bolt", color:COLORS.player, max:8, short:"bounces",
    fire:(dt)=>{
      const lvl=player.upgrades.spark|0;
      const cdBase=0.78 * Math.pow(0.92, lvl-1);
      weaponCD("spark", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=600*player.projSpd;
        const dmg=0.95*player.dmg*(1+0.08*(lvl-1));
        const bnc=(1 + Math.floor((lvl-1)/2)) + (player.upgrades.bounce||0);
        spawnBullet(player.x,player.y, dx*sp,dy*sp, 4.8*DPR*SIZE_MULT, dmg, 1.0, COLORS.player, 0, bnc, rollCrit(1.0), 0.6, true);
      });
    }
  },
  {key:"flame", name:"hellfire", color:COLORS.chest, max:8, short:"rapid fire",
    fire:(dt)=>{
      const lvl=player.upgrades.flame|0;
      const cdBase=0.48 * Math.pow(0.92, lvl-1);
      weaponCD("flame", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=540*player.projSpd*(1+0.04*(lvl-1));
        const dmg=0.85*player.dmg*(1+0.10*(lvl-1));
        spawnBullet(player.x,player.y, dx*sp,dy*sp, (4.0+0.22*(lvl-1))*DPR*SIZE_MULT, dmg, 1.0, COLORS.chest, 0,0, rollCrit(0.9), 0.65, true);
      });
    }
  },
  {key:"orb", name:"void orbit", color:"#d7dbe8", max:8, short:"burst",
    fire:(dt)=>{
      const lvl=player.upgrades.orb|0;
      const cdBase=1.35 * Math.pow(0.92, lvl-1);
      weaponCD("orb", dt, cdBase, ()=>{
        const dmg=1.05*player.dmg*(1+0.07*(lvl-1));
        const n=6 + Math.min(10, Math.floor((lvl-1)/1.5) + (player.upgrades.multi||0));
        const sp=450*player.projSpd*(1+0.05*(lvl-1));
        for(let i=0;i<n;i++){
          const a=(i/n)*Math.PI*2;
          spawnBullet(player.x,player.y, Math.cos(a)*sp,Math.sin(a)*sp, 3.4*DPR*SIZE_MULT, dmg, 0.95, "#d7dbe8", 0,0,false,0.0,true);
        }
      });
    }
  },
  {key:"lance", name:"holy lance", color:"#ffffff", max:8, short:"piercing",
    fire:(dt)=>{
      const lvl=player.upgrades.lance|0;
      const cdBase=2.1 * Math.pow(0.92, lvl-1);
      weaponCD("lance", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=920*player.projSpd;
        const dmg=3.1*player.dmg*(1+0.14*(lvl-1));
        const pier=4 + Math.floor((lvl-1)/1.5) + (player.upgrades.pierce||0);
        const r=(5.4+0.2*(lvl-1))*DPR*SIZE_MULT;
        spawnBullet(player.x,player.y, dx*sp,dy*sp, r, dmg, 0.85, "#ffffff", pier,0, rollCrit(1.2), 1.2, true);
      });
    }
  },
  {key:"saw", name:"bone saw", color:COLORS.gem, max:8, short:"slow blender",
    fire:(dt)=>{
      const lvl=player.upgrades.saw|0;
      const cdBase=1.15 * Math.pow(0.92, lvl-1);
      weaponCD("saw", dt, cdBase, ()=>{
        const [dx,dy]=aimDir();
        const sp=290*player.projSpd;
        const dmg=1.65*player.dmg*(1+0.09*(lvl-1));
        const life=1.4 + 0.18*(lvl-1);
        const pier=2 + Math.floor((lvl-1)/2) + (player.upgrades.pierce||0);
        spawnBullet(player.x,player.y, dx*sp,dy*sp, (9.4+0.6*(lvl-1))*DPR*SIZE_MULT, dmg, life, COLORS.gem, pier,0,false,0.0,true);
      });
    }
  },
];

const passiveDefs=[
  {key:"damage", name:"damage", max:10, short:"+dmg"},
  {key:"atk", name:"attack speed", max:10, short:"+atk spd"},
  {key:"crit", name:"crit", max:10, short:"+crit%"},
  {key:"critd", name:"crit dmg", max:10, short:"+crit dmg"},
  {key:"move", name:"move", max:8, short:"+move"},
  {key:"hp", name:"max hp", max:8, short:"+hp"},
  {key:"armor", name:"armor", max:8, short:"-dmg taken"},
  {key:"multi", name:"multi-shot", max:8, short:"+shots"},
  {key:"pierce", name:"pierce", max:8, short:"+pierce"},
  {key:"bounce", name:"bounce", max:8, short:"+bounces"},
  {key:"magnet", name:"magnet", max:10, short:"+pickup"},
  {key:"luck", name:"luck", max:10, short:"+better rolls"},
];

/* Weapon cooldown tracker */
const wcd={};
function weaponCD(key, dt, cdBase, fireFn){
  let cd=wcd[key]||0;
  cd-=dt*(1 + (buffFrenzy>0?0.65:0));
  if(cd>0){ wcd[key]=cd; return; }
  wcd[key]=cdBase/(player.atkSpd*(buffFrenzy>0?1.45:1));
  fireFn();
}
function rollCrit(mult=1.0){
  const p=clamp(player.crit*mult,0,0.70);
  return rng.chance(p);
}

/* ============================
   Aim helper
============================ */
function aimDir(){
  let dx=0,dy=-1;
  const mx=mouseX-W*0.5, my=mouseY-H*0.5;
  const m2=mx*mx+my*my;
  const mouseBias=m2>40*40?0.55:0.0;

  let best=-1, bd=1e18;
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.active) continue;
    const d=len2(e.x-player.x, e.y-player.y);
    if(d<bd){ bd=d; best=i; }
  }
  if(best!==-1){ const e=enemies[best]; dx=e.x-player.x; dy=e.y-player.y; }
  if(mouseBias>0){ dx=dx*(1-mouseBias)+mx*mouseBias; dy=dy*(1-mouseBias)+my*mouseBias; }
  return norm(dx,dy);
}

/* ============================
   Bullets
============================ */
function spawnBullet(x,y,vx,vy,r,dmg,life,color,pierce=0,bounce=0,crit=false,trail=0,fromPlayer=true){
  if(bullets.length>=MAX_BULLETS) return;
  const b=bulletPool.get();
  b.active=true; b.x=x; b.y=y; b.vx=vx; b.vy=vy; b.r=r; b.dmg=dmg*(buffDouble>0?2:1); b.life=life;
  b.pierce=pierce; b.bounce=bounce; b.color=color; b.crit=crit; b.trail=trail; b.fromPlayer=fromPlayer;
  bullets.push(b);
}

/* ============================
   Spawn enemies (more distinct behaviors)
============================ */
function spawnEnemy(type,x,y,elite=false, boss=false){
  if(enemies.length>=MAX_ENEMIES) return;
  const e=enemyPool.get();
  e.active=true; e.type=type; e.x=x; e.y=y; e.vx=0; e.vy=0; e.elite=elite; e.mod=0; e.boss=boss;
  e.cd=0; e.showDmgT=0;

  // Very clear archetypes:
  // RUNNER: fast, low hp
  // TANK: slow, huge, high dmg
  // SPITTER: medium, shoots
  // SPLITTER: medium, splits into swarm
  // BOSS: huge, slow, very high hp, drops chest
  let baseHp=3, baseSpd=24, r=11*DPR*SIZE_MULT, dmg=1;

  if(type===ENEMY.SWARM){ baseHp=2; baseSpd=22; r=10*DPR*SIZE_MULT; dmg=1; }
  if(type===ENEMY.RUNNER){ baseHp=2; baseSpd=58; r=9*DPR*SIZE_MULT; dmg=1; }
  if(type===ENEMY.TANK){ baseHp=10; baseSpd=14; r=18*DPR*SIZE_MULT; dmg=3; }
  if(type===ENEMY.SPITTER){ baseHp=4; baseSpd=20; r=13*DPR*SIZE_MULT; dmg=1; e.cd=1.1; }
  if(type===ENEMY.SPLITTER){ baseHp=5; baseSpd=18; r=14*DPR*SIZE_MULT; dmg=2; }
  if(type===ENEMY.ELITE){ baseHp=12; baseSpd=24; r=18*DPR*SIZE_MULT; dmg=2; e.mod=rng.i(3); e.elite=true; }
  if(type===ENEMY.BOSS){ baseHp=90; baseSpd=12; r=30*DPR*SIZE_MULT; dmg=5; e.boss=true; e.cd=0.9; }

  const sH=hpScale(tRun)*(elite?1.35:1);
  const sS=spdScale(tRun)*(elite?1.15:1);

  // bosses scale harder over time
  const bossMul = (type===ENEMY.BOSS) ? (1 + (tRun/120)*0.55) : 1;

  e.maxhp=Math.max(1, (baseHp*sH*bossMul)|0);
  e.hp=e.maxhp;
  e.spd=baseSpd*sS;
  e.r=r;
  e.dmg=dmg;
  enemyStyle(e);
  enemies.push(e);
}

/* ============================
   Spawning (enemies + periodic bosses)
============================ */
function spawnRatePerSec(t){
  const t0=Math.max(0, t-12);
  const corr=corrMult();
  const rate = 0.10 * Math.exp(t0/55) * corr;
  return Math.min(52, rate);
}
let bossTimer=75;        // first boss ~1:15
let bossAlive=false;

function spawnBoss(){
  // only one boss at a time
  if(bossAlive) return;
  bossAlive=true;
  audio.s_boss(); addShake(16);
  floatText(player.x, player.y-60, "BOSS INCOMING!", COLORS.enemyBullet, true);

  const pad=120*DPR;
  const side=rng.i(4);
  let x,y;
  if(side===0){ x=player.x + (rng.f()*W - W/2)/ZOOM_BASE; y=player.y - (H/2 + pad)/ZOOM_BASE; }
  if(side===1){ x=player.x + (W/2 + pad)/ZOOM_BASE; y=player.y + (rng.f()*H - H/2)/ZOOM_BASE; }
  if(side===2){ x=player.x + (rng.f()*W - W/2)/ZOOM_BASE; y=player.y + (H/2 + pad)/ZOOM_BASE; }
  if(side===3){ x=player.x - (W/2 + pad)/ZOOM_BASE; y=player.y + (rng.f()*H - H/2)/ZOOM_BASE; }

  spawnEnemy(ENEMY.BOSS, x,y, false, true);
}

function spawnStep(dt){
  const tAdj=tRun*(1 + (player.corr|0)*0.02);
  const rate=spawnRatePerSec(tAdj);
  spawnAcc += rate*dt;

  const frameCap=44;
  let spawned=0;

  while(spawnAcc>=1 && spawned<frameCap){
    spawnAcc-=1; spawned++;

    const t=tAdj;
    let weights;
    if(t<40){
      weights=[{w:4.0,v:ENEMY.SWARM},{w:0.8,v:ENEMY.RUNNER}];
    }else if(t<120){
      weights=[{w:3.0,v:ENEMY.SWARM},{w:2.0,v:ENEMY.RUNNER},{w:1.0,v:ENEMY.TANK}];
    }else if(t<240){
      weights=[{w:2.4,v:ENEMY.SWARM},{w:2.1,v:ENEMY.RUNNER},{w:1.3,v:ENEMY.TANK},{w:1.1,v:ENEMY.SPITTER},{w:1.0,v:ENEMY.SPLITTER}];
    }else{
      weights=[{w:2.2,v:ENEMY.SWARM},{w:2.3,v:ENEMY.RUNNER},{w:1.7,v:ENEMY.TANK},{w:1.6,v:ENEMY.SPITTER},{w:1.3,v:ENEMY.SPLITTER}];
    }

    const type=rng.weighted(weights);
    const eliteP=clamp(0.006 + tAdj/800*0.03 + player.luck*0.012 + corrDropBonus()*0.2, 0.006, 0.08);
    const elite=rng.chance(eliteP);
    const finalType=elite?ENEMY.ELITE:type;

    const pad=90*DPR;
    const side=rng.i(4);
    let x,y;
    if(side===0){ x=player.x + (rng.f()*W - W/2)/ZOOM_BASE; y=player.y - (H/2 + pad)/ZOOM_BASE; }
    if(side===1){ x=player.x + (W/2 + pad)/ZOOM_BASE; y=player.y + (rng.f()*H - H/2)/ZOOM_BASE; }
    if(side===2){ x=player.x + (rng.f()*W - W/2)/ZOOM_BASE; y=player.y + (H/2 + pad)/ZOOM_BASE; }
    if(side===3){ x=player.x - (W/2 + pad)/ZOOM_BASE; y=player.y + (rng.f()*H - H/2)/ZOOM_BASE; }

    spawnEnemy(finalType,x,y,elite);
  }

  // periodic bosses
  bossTimer -= dt;
  if(bossTimer<=0){
    bossTimer = 80 + rng.f()*35; // every ~1:20–2:00
    spawnBoss();
  }

  // Doom pressure at 12 minutes
  if(!doomSpawned && tRun>=12*60){
    doomSpawned=true;
    audio.s_boss(); addShake(18);
    floatText(player.x, player.y-60, "DOOM PRESSURE!", COLORS.enemy, true);
    for(let i=0;i<18;i++){
      const a=(i/18)*Math.PI*2;
      const dist=(Math.min(W,H)*0.55)/ZOOM_BASE + rng.f()*120*DPR/ZOOM_BASE;
      spawnEnemy(ENEMY.ELITE, player.x+Math.cos(a)*dist, player.y+Math.sin(a)*dist, true);
    }
  }
}

/* ============================
   Grid rebuild
============================ */
function rebuildGrid(){
  grid.clear();
  for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.active) grid.insert("e",i,e.x,e.y); }
  for(let i=0;i<bullets.length;i++){ const b=bullets[i]; if(b.active) grid.insert("b",i,b.x,b.y); }
  for(let i=0;i<gems.length;i++){ const g=gems[i]; if(g.active) grid.insert("g",i,g.x,g.y); }
  for(let i=0;i<drops.length;i++){ const d=drops[i]; if(d.active) grid.insert("d",i,d.x,d.y); }
}

/* ============================
   Damage / kill (MORE DAMAGE NUMBERS)
============================ */
let dmgWindow=0, dmgWinT=0.6, dpsEst=0;
let killsInWindow=0, killWinT=0.35;

function damageEnemy(e, dmg, isCrit, sx, sy){
  dmgWindow+=dmg;
  e.hp -= dmg;

  // big feedback
  if(isCrit){
    audio.s_crit(); addShake(3);
    burst(e.x,e.y, 9, 170, "rgba(255,209,102,.85)", 1.2*DPR, 3.4*DPR, 0.12, 0.34);
  }else{
    burst(e.x,e.y, 6, 120, "rgba(233,238,252,.40)", 1.0*DPR, 2.6*DPR, 0.10, 0.22);
  }

  // damage numbers (lots, but throttled per enemy a bit)
  e.showDmgT -= 0.01;
  if((floats.length<MAX_FLOATS-12) && (rng.f()<DAMAGE_FLOAT_CHANCE) && e.showDmgT<=0){
    e.showDmgT = isCrit ? 0.02 : 0.04;
    const txt = isCrit ? ("✦"+Math.round(dmg)) : (""+Math.round(dmg));
    floatText(e.x, e.y - e.r*0.35, txt, isCrit ? "#ffd166" : "#e9eefc", isCrit);
  }

  // knockback
  const k=44*(1 + (player.upgrades.knock||0)*0.15);
  const [nx,ny]=norm(e.x-sx, e.y-sy);
  e.vx += nx*k; e.vy += ny*k;

  if(e.hp<=0){
    const wasBoss = e.type===ENEMY.BOSS || e.boss;
    e.active=false;
    killsInWindow++;

    // streak reward
    streakMeter += streakGain;
    streakTimer = 1.0;
    if(streakMeter>1) streak = clamp(1 + (streakMeter-1)*0.25, 1, streakCap);

    // boss death: chest drop
    if(wasBoss){
      bossAlive=false;
      spawnDrop(e.x,e.y, DROP.CHEST);
      floatText(e.x, e.y-60, "CHEST DROPPED!", COLORS.chest, true);
      addShake(18);
    }

    // regular drops
    const bonus=corrDropBonus();
    const dropRoll=rng.f();

    const pFood=0.018 + bonus*0.6;
    const pMag =0.010 + bonus*0.5;
    const pFren=0.012 + bonus*0.45;
    const pDbl =0.010 + bonus*0.40;
    const pNuke=0.004 + bonus*0.25;

    if(!wasBoss){
      if(dropRoll < pNuke) spawnDrop(e.x,e.y, DROP.NUKE);
      else if(dropRoll < pNuke+pDbl) spawnDrop(e.x,e.y, DROP.DOUBLE);
      else if(dropRoll < pNuke+pDbl+pFren) spawnDrop(e.x,e.y, DROP.FRENZY);
      else if(dropRoll < pNuke+pDbl+pFren+pMag) spawnDrop(e.x,e.y, DROP.MAGNET);
      else if(dropRoll < pNuke+pDbl+pFren+pMag+pFood) spawnDrop(e.x,e.y, DROP.FOOD);
    }

    // gem drop (green)
    let rare=0;
    const r=rng.f() + player.luck*0.12 + (e.elite?0.14:0) + bonus*0.9 + (wasBoss?0.35:0);
    if(r>1.08) rare=3; else if(r>0.94) rare=2; else if(r>0.78) rare=1;
    const val = wasBoss ? (5 + rare*2) : (e.elite ? (2+rare) : (1 + (rare?1:0)));
    spawnGem(e.x,e.y,val,rare);

    // boss drops extra gems
    if(wasBoss){
      for(let i=0;i<10;i++){
        spawnGem(e.x + (rng.f()*2-1)*22*DPR/ZOOM_BASE, e.y + (rng.f()*2-1)*22*DPR/ZOOM_BASE, 2, 1);
      }
      audio.s_explo();
    }

    // splitter
    if(e.type===ENEMY.SPLITTER){
      for(let i=0;i<2;i++){
        const a=rng.f()*Math.PI*2;
        spawnEnemy(ENEMY.SWARM, e.x+Math.cos(a)*18*DPR/ZOOM_BASE, e.y+Math.sin(a)*18*DPR/ZOOM_BASE, false);
      }
    }

    // explosion FX
    burst(e.x,e.y, e.elite?18:12, e.elite?220:200, e.elite?"rgba(255,255,255,.70)":"rgba(255,59,92,.55)", 1.1*DPR, 3.8*DPR, 0.12, 0.42);
  }
}

/* ============================
   Player damage / dash
============================ */
function hurtPlayer(dmg){
  if(player.iFrames>0) return;
  const reduced=Math.max(1, dmg - (player.upgrades.armor||0) - player.armor);
  player.hp -= reduced;
  player.iFrames=0.50;
  addShake(7);
  audio.s_hurt();
  burst(player.x,player.y, 14, 200, "rgba(255,59,92,.55)", 1.2*DPR, 3.6*DPR, 0.12, 0.34);

  streakMeter=Math.max(0, streakMeter-0.95);
  streak=clamp(1 + Math.max(0,streakMeter-1)*0.25, 1, streakCap);

  if(player.hp<=0){ player.hp=0; endRun(); }
}
function dash(dt){
  if(player.dashCd>0) player.dashCd-=dt;
  if(player.dashing>0) player.dashing-=dt;
  if(keys.has("Space") && player.dashCd<=0 && state==="RUN"){
    let dx=0,dy=0;
    if(keys.has("KeyW")) dy-=1;
    if(keys.has("KeyS")) dy+=1;
    if(keys.has("KeyA")) dx-=1;
    if(keys.has("KeyD")) dx+=1;
    if(dx===0&&dy===0){ dx=mouseX-W*0.5; dy=mouseY-H*0.5; }
    const [nx,ny]=norm(dx,dy);
    player.vx += nx*760*DPR/ZOOM_BASE;
    player.vy += ny*760*DPR/ZOOM_BASE;
    player.dashCd=player.dashMax;
    player.dashing=0.12;
    player.iFrames=Math.max(player.iFrames,0.18);
    audio.s_dash();
    addShake(9);
    burst(player.x,player.y, 18, 260, "rgba(69,184,255,.45)", 1.1*DPR, 3.2*DPR, 0.10, 0.26);
  }
}

/* ============================
   Passive scaling
============================ */
function applyPassiveScaling(){
  const u=player.upgrades;
  player.dmg = player.baseDmg * (1 + (u.damage||0)*(0.10 + 0.02*Math.max(0,(u.damage||0)-1)));
  player.atkSpd = player.baseAtk * (1 + (u.atk||0)*(0.10 + 0.02*Math.max(0,(u.atk||0)-1)));
  player.crit = clamp(player.baseCrit + (u.crit||0)*0.02, 0, 0.70);
  player.critDmg = player.baseCritD * (1 + (u.critd||0)*(0.12 + 0.03*Math.max(0,(u.critd||0)-1)));
  player.move = player.baseMove * (1 + (u.move||0)*(0.08 + 0.02*Math.max(0,(u.move||0)-1)));
  player.magnet = player.baseMagnet + (u.magnet||0)*(18 + 4*Math.max(0,(u.magnet||0)-1));
  player.luck = player.baseLuck + (u.luck||0)*0.06 + (u.luck||0)*0.015*Math.max(0,(u.luck||0)-1);
}

/* ============================
   Updates
============================ */
function updatePlayer(dt){
  if(player.iFrames>0) player.iFrames-=dt;

  let ax=0,ay=0;
  if(keys.has("KeyW")) ay-=1;
  if(keys.has("KeyS")) ay+=1;
  if(keys.has("KeyA")) ax-=1;
  if(keys.has("KeyD")) ax+=1;

  if(ax!==0||ay!==0){
    const [nx,ny]=norm(ax,ay);
    const sp=220*DPR*player.move*(player.dashing>0?1.3:1)/ZOOM_BASE;
    player.vx += nx*sp*dt*7;
    player.vy += ny*sp*dt*7;
  }
  const fr=Math.pow(0.001, dt);
  player.vx*=fr; player.vy*=fr;
  player.x += player.vx*dt;
  player.y += player.vy*dt;
}

function updateEnemies(dt){
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.active) continue;
    if(e.showDmgT>0) e.showDmgT-=dt;

    let dx=player.x-e.x, dy=player.y-e.y;
    const d=Math.hypot(dx,dy)||1;
    let nx=dx/d, ny=dy/d;

    // spitters (and bosses sometimes) shoot purple bullets
    if(e.type===ENEMY.SPITTER || (e.type===ENEMY.ELITE && e.mod===1) || (e.type===ENEMY.BOSS)){
      if(d<260*DPR/ZOOM_BASE){ nx=-nx; ny=-ny; } // keep distance
      e.cd -= dt;
      const shootRange = (e.type===ENEMY.BOSS) ? (680*DPR/ZOOM_BASE) : (520*DPR/ZOOM_BASE);
      if(e.cd<=0 && d<shootRange){
        e.cd = (e.type===ENEMY.BOSS)?(0.70+rng.f()*0.35):(1.05 + rng.f()*0.55);
        const spd=(e.type===ENEMY.BOSS)?(260*DPR/ZOOM_BASE):(210*DPR/ZOOM_BASE);
        const dmg=(e.type===ENEMY.BOSS)?(3 + (tRun/120)|0):(1 + (tRun/170)|0);
        spawnBullet(e.x,e.y, (dx/d)*spd, (dy/d)*spd, 5.2*DPR*SIZE_MULT, dmg, 2.2, COLORS.enemyBullet, 0,0,false,0.0,false);
      }
    }

    // movement
    const sp=e.spd;
    e.vx += nx*sp*dt*7;
    e.vy += ny*sp*dt*7;
    e.vx *= Math.pow(0.02, dt);
    e.vy *= Math.pow(0.02, dt);
    e.x += e.vx*dt;
    e.y += e.vy*dt;

    // contact damage
    const rr=e.r+player.r;
    if(len2(e.x-player.x, e.y-player.y)<=rr*rr){
      hurtPlayer(e.dmg);
      e.vx -= nx*240*DPR/ZOOM_BASE;
      e.vy -= ny*240*DPR/ZOOM_BASE;
    }
  }
}

function updateBullets(dt){
  for(let i=0;i<bullets.length;i++){
    const b=bullets[i]; if(!b.active) continue;
    b.life -= dt;
    if(b.life<=0){ b.active=false; continue; }
    b.x += b.vx*dt; b.y += b.vy*dt;

    if(!b.fromPlayer){
      const rr=b.r+player.r;
      if(len2(b.x-player.x, b.y-player.y)<=rr*rr){ b.active=false; hurtPlayer(b.dmg); }
    }
  }
}

function collideBullets(){
  for(let bi=0;bi<bullets.length;bi++){
    const b=bullets[bi]; if(!b.active||!b.fromPlayer) continue;

    grid.query(b.x,b.y,tmpKeys);
    for(let k=0;k<tmpKeys.length;k++){
      const bucket=grid.map.get(tmpKeys[k]); if(!bucket) continue;
      const list=bucket.e;
      for(let j=0;j<list.length;j++){
        const e=enemies[list[j]]; if(!e.active) continue;
        const rr=b.r+e.r;
        const dx=e.x-b.x, dy=e.y-b.y;
        if(dx*dx+dy*dy<=rr*rr){
          const isCrit=b.crit;
          const dealt = b.dmg*(isCrit?player.critDmg:1);
          damageEnemy(e, dealt, isCrit, b.x,b.y);

          if(b.pierce>0){
            b.pierce--;
          }else if(b.bounce>0){
            b.bounce--;
            let best=-1, bd=1e18;
            for(let ii=0;ii<enemies.length;ii++){
              const ee=enemies[ii]; if(!ee.active||ee===e) continue;
              const d2=len2(ee.x-b.x, ee.y-b.y);
              if(d2<bd){ bd=d2; best=ii; }
            }
            if(best!==-1){
              const ee=enemies[best];
              const [nx,ny]=norm(ee.x-b.x, ee.y-b.y);
              const sp=Math.hypot(b.vx,b.vy);
              b.vx=nx*sp; b.vy=ny*sp;
            }else b.active=false;
          }else b.active=false;
          break;
        }
      }
      if(!b.active) break;
    }
  }
}

function updateParticles(dt){
  for(let i=0;i<particles.length;i++){
    const p=particles[i]; if(!p.active) continue;
    p.life -= dt;
    if(p.life<=0){ p.active=false; continue; }
    p.x += p.vx*dt; p.y += p.vy*dt;
    p.vx *= Math.pow(0.03, dt);
    p.vy *= Math.pow(0.03, dt);
  }
}
function updateFloats(dt){
  for(let i=0;i<floats.length;i++){
    const f=floats[i]; if(!f.active) continue;
    f.life -= dt;
    if(f.life<=0){ f.active=false; continue; }
    f.y += f.vy*dt;
  }
}
function updateStreak(dt){
  if(streakTimer>0) streakTimer-=dt;
  const dec=(streakTimer>0?0.10:0.26)*streakDecay;
  streakMeter=Math.max(0, streakMeter-dec*dt);
  streak=clamp(1 + Math.max(0,streakMeter-1)*0.25, 1, streakCap);
}

function updateDrops(dt){
  if(magnetAll>0) magnetAll-=dt;
  if(buffFrenzy>0) buffFrenzy-=dt;
  if(buffDouble>0) buffDouble-=dt;

  for(let i=0;i<drops.length;i++){
    const d=drops[i]; if(!d.active) continue;
    d.t += dt;
    d.vx *= Math.pow(0.02, dt);
    d.vy *= Math.pow(0.02, dt);
    d.x += d.vx*dt;
    d.y += d.vy*dt;

    const rr=d.r+player.r;
    if(len2(d.x-player.x, d.y-player.y)<=rr*rr){
      d.active=false;
      applyDrop(d.kind);
    }
  }
}

function updateGems(dt){
  const mag = player.magnet + 34;
  const mag2=(mag*DPR)*(mag*DPR);

  const global = magnetAll>0;

  for(let i=0;i<gems.length;i++){
    const g=gems[i]; if(!g.active) continue;

    let dx=player.x-g.x, dy=player.y-g.y;
    let d2=dx*dx+dy*dy;

    if(global || d2<mag2){
      const d=Math.sqrt(d2)||1;
      const pull=((global?2200:1200)*DPR/ZOOM_BASE) * (global?1:(1 - d/Math.sqrt(mag2))) * dt;
      g.vx += (dx/d)*pull;
      g.vy += (dy/d)*pull;
    }

    g.vx *= Math.pow(0.02, dt);
    g.vy *= Math.pow(0.02, dt);
    g.x += g.vx*dt;
    g.y += g.vy*dt;

    const rr=g.r+player.r;
    if(d2<=rr*rr){
      g.active=false;
      const xpGainBase=3 + g.val + (g.rare>=2?2:0);
      const xpGain=xpGainBase*streak;
      player.xp += xpGain;
      player.shardsRun += (g.val + (g.rare>=1?1:0));
      audio.s_pick();
      burst(player.x,player.y, 8, 140, "rgba(45,255,136,.50)", 1.0*DPR, 2.6*DPR, 0.10, 0.22);

      while(player.xp>=player.xpNeed){
        player.xp -= player.xpNeed;
        player.lvl++;
        player.xpNeed = Math.floor(player.xpNeed*1.18+2);
        openAltar();
        break;
      }
    }
  }
}

/* ============================
   Fire all owned weapons
============================ */
function fireWeapons(dt){
  for(let i=0;i<weaponDefs.length;i++){
    const wd=weaponDefs[i];
    const lvl=player.upgrades[wd.key]|0;
    if(lvl>0) wd.fire(dt);
  }
}

/* ============================
   ALTAR + CHEST (simple text)
============================ */
let altarChoices=[];
function upLevel(key, max){
  const cur=player.upgrades[key]|0;
  if(cur>=max) return false;
  player.upgrades[key]=cur+1;
  return true;
}
function roman(n){
  const map=[[10,"X"],[9,"IX"],[5,"V"],[4,"IV"],[1,"I"]];
  let s=""; let k=n;
  for(const [v,ch] of map){ while(k>=v){ s+=ch; k-=v; } }
  return s||"I";
}
function passiveByKey(key){ for(let i=0;i<passiveDefs.length;i++) if(passiveDefs[i].key===key) return passiveDefs[i]; return null; }
function weaponByKey(key){ for(let i=0;i<weaponDefs.length;i++) if(weaponDefs[i].key===key) return weaponDefs[i]; return null; }

function pickUpgradeCandidate(bias="ANY"){
  const candidates=[];
  if(bias==="WEAPON"){
    for(const wd of weaponDefs){
      const lvl=player.upgrades[wd.key]|0;
      if(lvl<wd.max){
        const w=(lvl===0?3.2:1.6);
        candidates.push({w, v:{kind:"WEAPON", key:wd.key}});
      }
    }
  }else if(bias==="PASSIVE"){
    for(const pd of passiveDefs){
      const lvl=player.upgrades[pd.key]|0;
      if(lvl<pd.max) candidates.push({w:1.8, v:{kind:"PASSIVE", key:pd.key}});
    }
  }else{
    for(const wd of weaponDefs){
      const lvl=player.upgrades[wd.key]|0;
      if(lvl<wd.max){
        const w = (lvl===0? 3.0 : 1.4) * (wd.key==="pebble"?0.7:1.0);
        candidates.push({w, v:{kind:"WEAPON", key:wd.key}});
      }
    }
    for(const pd of passiveDefs){
      const lvl=player.upgrades[pd.key]|0;
      if(lvl<pd.max) candidates.push({w:1.6, v:{kind:"PASSIVE", key:pd.key}});
    }
  }
  return rng.weighted(candidates);
}

function fmtUpgrade(u){
  if(u.kind==="WEAPON"){
    const wd=weaponByKey(u.key);
    const lvl=(player.upgrades[u.key]|0)+1;
    return {
      title:`${wd.name} ${roman(lvl)}`,
      desc:`+1 weapon level · ${wd.short}`,
      stripe:lvl>=6?"EPIC":(lvl>=4?"RARE":""),
      stripeStyle: lvl>=6?`color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)`:(lvl>=4?`color:var(--rare);border-color:rgba(122,162,255,.32);background:rgba(122,162,255,.16)`:"")
    };
  }else{
    const pd=passiveByKey(u.key);
    const lvl=(player.upgrades[u.key]|0)+1;
    return {
      title:`${pd.name} ${roman(lvl)}`,
      desc:`+1 level · ${pd.short}`,
      stripe:lvl>=7?"EPIC":(lvl>=4?"RARE":""),
      stripeStyle: lvl>=7?`color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)`:(lvl>=4?`color:var(--rare);border-color:rgba(122,162,255,.32);background:rgba(122,162,255,.16)`:"")
    };
  }
}

function applyUpgrade(u){
  if(u.kind==="WEAPON"){
    const wd=weaponByKey(u.key);
    const ok=upLevel(u.key, wd.max);
    if(ok) floatText(player.x,player.y-26, `${wd.name.toUpperCase()} +1`, wd.color, false);
  }else{
    const pd=passiveByKey(u.key);
    const ok=upLevel(u.key, pd.max);
    if(!ok) return;
    if(u.key==="hp"){
      const add=1+((player.upgrades.hp|0)%2);
      player.maxhp += add;
      player.hp = Math.min(player.maxhp, player.hp+add);
    }
    if(u.key==="armor"){ player.armor += 1; }
    if(u.key==="magnet"){ player.baseMagnet += 8; }
    if(u.key==="luck"){ player.baseLuck += 0.015; }
    floatText(player.x,player.y-26, `${pd.name.toUpperCase()} +1`, "#d7dbe8", false);
  }
}

const chaosMutationsBase=[
  {name:"bullet party", stripe:"EPIC", style:"color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)",
    desc:"+2 multi-shot · +1 corruption", apply:()=>{ upLevel("multi", passiveByKey("multi").max); upLevel("multi", passiveByKey("multi").max); } },
  {name:"glass cannon", stripe:"EPIC", style:"color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)",
    desc:"+80% dmg · -3 max hp", apply:()=>{ player.baseDmg*=1.80; player.maxhp=Math.max(1,player.maxhp-3); player.hp=Math.min(player.hp,player.maxhp); } },
  {name:"doom discount", stripe:"RARE", style:"color:var(--rare);border-color:rgba(122,162,255,.32);background:rgba(122,162,255,.16)",
    desc:"-12% XP needed · +1 corruption", apply:()=>{ player.xpNeed=Math.max(8, Math.floor(player.xpNeed*0.88)); } },
  {name:"void vacuum", stripe:"LEGEND", style:"color:var(--legend);border-color:rgba(255,138,61,.32);background:rgba(255,138,61,.16)",
    desc:"Magnet every 10s · +2 corruption", apply:()=>{ chaosVac=true; } },
];
let chaosVac=false;
let vacTimer=10;

function openOverlay(mode, title, sub){
  altarMode=mode;
  ui.altarTitle.textContent=title;
  ui.altarSub.textContent=sub;
  state="ALTAR";
  ui.altar.classList.add("show");
}
function closeOverlay(){
  ui.altar.classList.remove("show");
  state="RUN";
}
function openAltar(){
  openOverlay("ALTAR","ALTAR OF RISK","Pick SAFE / GAMBLE / CHAOS. (1 / 2 / 3)");
  ui.cards.innerHTML="";
  altarChoices = makeAltarChoices();
  ui.nearMiss.textContent = altarChoices.nearMiss || "—";
  ui.luckTag.textContent = Math.round(player.luck*100)+"%";

  for(let i=0;i<3;i++){
    const c=altarChoices[i];
    const div=document.createElement("div");
    div.className="pick "+(c.kind==="SAFE"?"safeGlow":(c.kind==="GAMBLE"?"gambleGlow":"chaosGlow"));
    div.innerHTML=`
      <div class="hotkey">${i+1}</div>
      <div class="title">
        <div class="type">${c.kind}</div>
        <div class="k">${c.sub}</div>
      </div>
      <div class="name">${c.title}</div>
      <div class="desc">${c.desc}</div>
      ${c.odds?`<div class="odds">${c.odds}</div>`:`<div class="odds"><span class="muted">pick ${i+1}</span></div>`}
      ${c.stripe?`<div class="stripe" style="${c.stripeStyle||""}">${c.stripe}</div>`:""}
    `;
    div.addEventListener("click",()=>pickCard(i));
    ui.cards.appendChild(div);
  }

  audio.s_lvl(); addShake(10);
}
function openChest(){
  openOverlay("CHEST","CHEST REWARD","Pick 1 big upgrade. (1 / 2 / 3)");
  ui.cards.innerHTML="";
  altarChoices = makeChestChoices();
  ui.nearMiss.textContent = "—";
  ui.luckTag.textContent = Math.round(player.luck*100)+"%";

  for(let i=0;i<3;i++){
    const c=altarChoices[i];
    const div=document.createElement("div");
    div.className="pick safeGlow";
    div.innerHTML=`
      <div class="hotkey">${i+1}</div>
      <div class="title">
        <div class="type">CHEST</div>
        <div class="k">${c.sub}</div>
      </div>
      <div class="name">${c.title}</div>
      <div class="desc">${c.desc}</div>
      <div class="odds"><b>Good</b> (no corruption)</div>
      ${c.stripe?`<div class="stripe" style="${c.stripeStyle||""}">${c.stripe}</div>`:""}
    `;
    div.addEventListener("click",()=>pickCard(i));
    ui.cards.appendChild(div);
  }
}

function makeChestChoices(){
  // Chests are always “good”: either +2 levels to something, or +1 weapon +1 passive.
  const out=[];
  const uW = pickUpgradeCandidate("WEAPON");
  const uP = pickUpgradeCandidate("PASSIVE");

  // Option A: weapon +2 (or +1 if capped)
  out.push({
    kind:"CHEST", sub:"weapon boost",
    title:`${fmtUpgrade(uW).title}`,
    desc:`Weapon +2 levels (if possible).`,
    stripe:"EPIC", stripeStyle:`color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)`,
    apply:()=>{
      audio.s_chest(); addShake(12);
      applyUpgrade(uW); applyUpgrade(uW);
      floatText(player.x,player.y-52,"CHEST POWER!", COLORS.chest, true);
    }
  });

  // Option B: damage +1 AND atk speed +1 (simple, always good)
  out.push({
    kind:"CHEST", sub:"raw power",
    title:"power pack",
    desc:"+1 damage level · +1 attack speed level",
    stripe:"RARE", stripeStyle:`color:var(--rare);border-color:rgba(122,162,255,.32);background:rgba(122,162,255,.16)`,
    apply:()=>{
      audio.s_chest(); addShake(10);
      applyUpgrade({kind:"PASSIVE", key:"damage"});
      applyUpgrade({kind:"PASSIVE", key:"atk"});
      floatText(player.x,player.y-52,"POWER PACK!", COLORS.power, true);
    }
  });

  // Option C: weapon +1 AND multi-shot +1 (very satisfying)
  out.push({
    kind:"CHEST", sub:"more bullets",
    title:"more bullets",
    desc:"Weapon +1 level · +1 multi-shot level",
    stripe:"EPIC", stripeStyle:`color:var(--epic);border-color:rgba(199,125,255,.32);background:rgba(199,125,255,.16)`,
    apply:()=>{
      audio.s_chest(); addShake(12);
      applyUpgrade(uP.kind?uP:{kind:"WEAPON", key:"pebble"});
      applyUpgrade({kind:"PASSIVE", key:"multi"});
      floatText(player.x,player.y-52,"BULLET STORM!", COLORS.epic, true);
    }
  });

  return out;
}

function makeAltarChoices(){
  const out=[];

  // SAFE
  const u1=pickUpgradeCandidate();
  const a1=fmtUpgrade(u1);
  out.push({
    kind:"SAFE", sub:"steady",
    title:a1.title,
    desc:a1.desc,
    odds:"No corruption.",
    stripe:a1.stripe, stripeStyle:a1.stripeStyle,
    apply:()=>{ audio.s_click(); applyUpgrade(u1); floatText(player.x,player.y-44,"SAFE", COLORS.gem, true); }
  });

  // GAMBLE
  const u2=pickUpgradeCandidate();
  const a2=fmtUpgrade(u2);
  const riskCeil=clamp(meta.unlocks.riskCeiling|0,0,5);
  const luckShift=clamp(player.luck*0.25,0,0.12);
  const odds=clamp(0.58 + luckShift + riskCeil*0.01, 0.12, 0.90);
  out.push({
    kind:"GAMBLE", sub:"swingy",
    title:`${a2.title}`,
    desc:`Win: upgrade + small bonus · Lose: -dmg/-atk + corruption`,
    odds:`Odds: <b>${Math.round(odds*100)}%</b> win`,
    stripe:"", stripeStyle:"",
    apply:()=>{
      const ok=rng.chance(odds);
      ui.nearMiss.textContent = ok ? "LOSS (corruption)" : "WIN (upgrade)";
      if(ok){
        applyUpgrade(u2);
        player.baseDmg *= (1 + 0.03*riskCeil);
        player.baseAtk *= (1 + 0.02*riskCeil);
        floatText(player.x,player.y-44,"GAMBLE WON!", COLORS.power, true);
        addShake(8);
      }else{
        player.corr += 1;
        player.baseDmg *= 0.93;
        player.baseAtk *= 0.93;
        floatText(player.x,player.y-44,"GAMBLE LOST!", COLORS.enemy, true);
        addShake(6);
      }
      audio.s_click();
    }
  });

  // CHAOS
  const mut = rng.pick(chaosMutationsBase);
  const chaosUp = pickUpgradeCandidate();
  const chaosFmt = fmtUpgrade(chaosUp);
  out.push({
    kind:"CHAOS", sub:"+power +corrupt",
    title:`${mut.name}`,
    desc:`${mut.desc}<br>+ also: <b>${chaosFmt.title}</b>`,
    odds:`Cost: <b>+1 corruption</b>`,
    stripe:mut.stripe||"", stripeStyle:mut.style||"",
    apply:()=>{
      player.corr += 1;
      mut.apply();
      applyUpgrade(chaosUp);
      floatText(player.x,player.y-52,"CHAOS!", COLORS.epic, true);
      addShake(12);
      audio.s_click();
    }
  });

  out.nearMiss = fmtUpgrade(pickUpgradeCandidate()).title;
  return out;
}

function pickCard(i){
  if(state!=="ALTAR") return;
  const c=altarChoices[i];
  if(!c) return;
  c.apply();
  closeOverlay();
}

/* ============================
   HUD / hint
============================ */
let hintT=0;
function showHint(html, seconds=2.5){
  ui.hint.innerHTML=html;
  ui.hint.classList.add("show");
  hintT=seconds;
}
function hintStep(dt){
  if(hintT>0){
    hintT-=dt;
    if(hintT<=0) ui.hint.classList.remove("show");
  }
}
function formatTime(s){
  s=Math.max(0,s|0);
  const m=(s/60)|0;
  const ss=(s%60).toString().padStart(2,"0");
  return m+":"+ss;
}
function updateHUD(){
  ui.hudTime.textContent=formatTime(tRun);
  ui.hudLvl.textContent=player.lvl|0;
  ui.hudHP.textContent=`${player.hp|0}/${player.maxhp|0}`;
  ui.hudShards.textContent=player.shardsRun|0;
  ui.hudMute.textContent=audio.muted?"ON":"OFF";
  ui.hudDPS.textContent=(dpsEst|0);
  ui.hudStreak.textContent="x"+streak.toFixed(1);
  ui.hudCorr.textContent=player.corr|0;

  const pct=clamp(player.xp/player.xpNeed,0,1);
  ui.xpFill.style.width=(pct*100).toFixed(1)+"%";
  ui.xpText.textContent=`XP ${player.xp|0} / ${player.xpNeed|0}`;
}

/* ============================
   Rendering (bigger + clearer)
============================ */
function worldToScreen(x,y){
  const z=ZOOM_BASE;
  return [(x-cam.x)*z + W*0.5 + cam.sx, (y-cam.y)*z + H*0.5 + cam.sy];
}

function drawFloor(){
  ctx.save();
  ctx.globalAlpha=0.50;
  ctx.strokeStyle="rgba(255,255,255,.05)";
  ctx.lineWidth=1*DPR;
  const step=70*DPR;
  const z=ZOOM_BASE;
  const ox=(((-cam.x*z)%step)+step)%step;
  const oy=(((-cam.y*z)%step)+step)%step;
  for(let x=-step;x<W+step;x+=step){ ctx.beginPath(); ctx.moveTo(x+ox,0); ctx.lineTo(x+ox,H); ctx.stroke(); }
  for(let y=-step;y<H+step;y+=step){ ctx.beginPath(); ctx.moveTo(0,y+oy); ctx.lineTo(W,y+oy); ctx.stroke(); }
  ctx.restore();
}

function draw(){
  cam.x=player.x; cam.y=player.y;
  if(cam.shake>0){
    cam.shake*=0.85;
    cam.sx=(rng.f()*2-1)*cam.shake*DPR;
    cam.sy=(rng.f()*2-1)*cam.shake*DPR;
  }else{ cam.sx=0; cam.sy=0; }

  ctx.clearRect(0,0,W,H);
  drawFloor();

  // GEMS (GREEN diamonds)
  for(let i=0;i<gems.length;i++){
    const g=gems[i]; if(!g.active) continue;
    const [sx,sy]=worldToScreen(g.x,g.y);
    const col=(g.rare===3?COLORS.legend:(g.rare===2?COLORS.epic:(g.rare===1?COLORS.rare:COLORS.gem)));
    ctx.globalAlpha=0.95;
    ctx.fillStyle=col;
    const r=g.r*ZOOM_BASE;
    ctx.beginPath();
    ctx.moveTo(sx, sy-r); ctx.lineTo(sx+r, sy); ctx.lineTo(sx, sy+r); ctx.lineTo(sx-r, sy);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1;
    ctx.strokeStyle="rgba(0,0,0,.62)"; ctx.lineWidth=2.5*DPR; ctx.stroke();
  }

  // DROPS (GOLD circles + big icons; chest is ORANGE)
  for(let i=0;i<drops.length;i++){
    const d=drops[i]; if(!d.active) continue;
    const [sx,sy]=worldToScreen(d.x,d.y + Math.sin(d.t*4)*2*DPR/ZOOM_BASE);
    let col=COLORS.power, txt="";
    if(d.kind===DROP.MAGNET){ col=COLORS.gem; txt="M"; }
    if(d.kind===DROP.FOOD){ col=COLORS.power; txt="+"; }
    if(d.kind===DROP.FRENZY){ col=COLORS.rare; txt="F"; }
    if(d.kind===DROP.DOUBLE){ col=COLORS.chest; txt="x2"; }
    if(d.kind===DROP.NUKE){ col=COLORS.enemy; txt="☢"; }
    if(d.kind===DROP.CHEST){ col=COLORS.chest; txt="⬚"; }
    const r=d.r*ZOOM_BASE;
    ctx.fillStyle=col;
    ctx.globalAlpha=0.96;
    ctx.beginPath(); ctx.arc(sx,sy, r, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
    ctx.strokeStyle="rgba(0,0,0,.70)"; ctx.lineWidth=3*DPR; ctx.stroke();
    ctx.fillStyle="rgba(0,0,0,.78)";
    ctx.font=(14*DPR)+"px system-ui";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(txt, sx, sy);
  }

  // BULLETS (white/weapon color)
  for(let i=0;i<bullets.length;i++){
    const b=bullets[i]; if(!b.active) continue;
    const [sx,sy]=worldToScreen(b.x,b.y);
    if(b.trail>0){
      ctx.globalAlpha=0.20;
      ctx.strokeStyle=b.color;
      ctx.lineWidth=3*DPR;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx - b.vx*0.010*ZOOM_BASE, sy - b.vy*0.010*ZOOM_BASE);
      ctx.stroke();
      ctx.globalAlpha=1;
    }
    ctx.fillStyle=b.color;
    ctx.beginPath(); ctx.arc(sx,sy,b.r*ZOOM_BASE,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,.60)"; ctx.lineWidth=2*DPR; ctx.stroke();
  }

  // ENEMIES (red family, distinct shapes + bigger)
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.active) continue;
    const [sx,sy]=worldToScreen(e.x,e.y);
    const r=e.r*ZOOM_BASE;

    ctx.fillStyle=e.tint;
    ctx.strokeStyle=e.outline; ctx.lineWidth=3.5*DPR;

    ctx.beginPath();
    if(e.type===ENEMY.SWARM){
      ctx.arc(sx,sy,r,0,Math.PI*2);
    }else if(e.type===ENEMY.RUNNER){
      // diamond
      ctx.moveTo(sx, sy-r); ctx.lineTo(sx+r, sy); ctx.lineTo(sx, sy+r); ctx.lineTo(sx-r, sy); ctx.closePath();
    }else if(e.type===ENEMY.TANK){
      // big square
      ctx.rect(sx-r, sy-r, r*2, r*2);
    }else if(e.type===ENEMY.SPITTER){
      // triangle
      ctx.moveTo(sx, sy-r); ctx.lineTo(sx+r, sy+r); ctx.lineTo(sx-r, sy+r); ctx.closePath();
    }else if(e.type===ENEMY.SPLITTER){
      // circle with notch
      ctx.arc(sx,sy,r,0,Math.PI*2);
    }else if(e.type===ENEMY.ELITE){
      // hex
      const n=6;
      for(let k=0;k<n;k++){
        const a=(k/n)*Math.PI*2+0.25;
        const px=sx+Math.cos(a)*r, py=sy+Math.sin(a)*r;
        if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
    }else{
      // BOSS: fat octagon
      const n=8;
      for(let k=0;k<n;k++){
        const a=(k/n)*Math.PI*2+0.10;
        const rr = r*(k%2?0.96:1.06);
        const px=sx+Math.cos(a)*rr, py=sy+Math.sin(a)*rr;
        if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
    }
    ctx.fill(); ctx.stroke();

    // Boss/Elite HP bar (clear)
    if(e.elite || e.type===ENEMY.BOSS){
      const hpPct=clamp(e.hp/e.maxhp,0,1);
      const bw=Math.max(44*DPR, r*2.0);
      const bh=(e.type===ENEMY.BOSS?7:5)*DPR;
      ctx.fillStyle="rgba(0,0,0,.62)";
      ctx.fillRect(sx-bw/2, sy-r-12*DPR, bw, bh);
      ctx.fillStyle=(e.type===ENEMY.BOSS)?COLORS.enemyBullet:COLORS.power;
      ctx.fillRect(sx-bw/2, sy-r-12*DPR, bw*hpPct, bh);
    }
  }

  // PLAYER (BLUE, very distinct)
  const [px,py]=worldToScreen(player.x,player.y);
  const pr=player.r*ZOOM_BASE;

  // glow ring
  ctx.fillStyle="rgba(69,184,255,.18)";
  ctx.beginPath(); ctx.arc(px,py, pr*2.1, 0, Math.PI*2); ctx.fill();

  // main body
  ctx.fillStyle=COLORS.player;
  ctx.strokeStyle="rgba(0,0,0,.80)"; ctx.lineWidth=4*DPR;
  ctx.beginPath(); ctx.arc(px,py, pr*1.05, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // inner dot
  ctx.fillStyle="rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.arc(px,py, pr*0.42, 0, Math.PI*2); ctx.fill();

  // PLAYER HP BAR ABOVE HEAD
  const hpPct=clamp(player.hp/player.maxhp,0,1);
  const bw=70*DPR, bh=8*DPR;
  ctx.fillStyle="rgba(0,0,0,.65)";
  ctx.fillRect(px-bw/2, py-pr-18*DPR, bw, bh);
  ctx.fillStyle=COLORS.gem;
  ctx.fillRect(px-bw/2, py-pr-18*DPR, bw*hpPct, bh);
  if(player.iFrames>0){
    ctx.strokeStyle="rgba(255,255,255,.55)";
    ctx.lineWidth=2*DPR;
    ctx.strokeRect(px-bw/2, py-pr-18*DPR, bw, bh);
  }

  // dash cooldown ring
  const cd=clamp(player.dashCd/player.dashMax,0,1);
  if(cd>0){
    ctx.strokeStyle="rgba(255,255,255,.35)";
    ctx.lineWidth=3*DPR;
    ctx.beginPath();
    ctx.arc(px,py, pr*1.6, -Math.PI/2, -Math.PI/2 + (Math.PI*2*(1-cd)));
    ctx.stroke();
  }

  // particles
  for(let i=0;i<particles.length;i++){
    const p=particles[i]; if(!p.active) continue;
    const [sx,sy]=worldToScreen(p.x,p.y);
    const a=clamp(p.life/p.max,0,1);
    ctx.globalAlpha=a*p.a;
    ctx.fillStyle=p.col;
    ctx.beginPath(); ctx.arc(sx,sy,p.r*ZOOM_BASE,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;

  // float text
  for(let i=0;i<floats.length;i++){
    const f=floats[i]; if(!f.active) continue;
    const [sx,sy]=worldToScreen(f.x,f.y);
    const a=clamp(f.life/f.max,0,1);
    ctx.globalAlpha=a;
    ctx.font=(f.big?(20*DPR):(15*DPR))+"px system-ui";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillStyle="rgba(0,0,0,.70)";
    ctx.fillText(f.text, sx+2*DPR, sy+2*DPR);
    ctx.fillStyle=f.col;
    ctx.fillText(f.text, sx, sy);
  }
  ctx.globalAlpha=1;

  // vignette
  ctx.save();
  const grd=ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.15, W/2,H/2, Math.min(W,H)*0.62);
  grd.addColorStop(0,"rgba(0,0,0,0)");
  grd.addColorStop(1,"rgba(0,0,0,0.36)");
  ctx.fillStyle=grd;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

/* ============================
   Compact / pooling cleanup
============================ */
function compactArray(arr,pool){
  let w=0;
  for(let r=0;r<arr.length;r++){
    const o=arr[r];
    if(o.active) arr[w++]=o;
    else pool.free(o);
  }
  arr.length=w;
}
function compactPools(){
  compactArray(bullets, bulletPool);
  compactArray(enemies, enemyPool);
  compactArray(particles, partPool);
  compactArray(floats, floatPool);
  compactArray(gems, gemPool);
  compactArray(drops, dropPool);
}

/* ============================
   Run control
============================ */
function resetRun(charId){
  for(let i=0;i<bullets.length;i++) bullets[i].active=false;
  for(let i=0;i<enemies.length;i++) enemies[i].active=false;
  for(let i=0;i<particles.length;i++) particles[i].active=false;
  for(let i=0;i<floats.length;i++) floats[i].active=false;
  for(let i=0;i<gems.length;i++) gems[i].active=false;
  for(let i=0;i<drops.length;i++) drops[i].active=false;
  compactPools();

  player.x=0; player.y=0; player.vx=0; player.vy=0; player.r=12*DPR*SIZE_MULT;
  player.maxhp=10; player.hp=10;
  player.iFrames=0;
  player.lvl=1; player.xp=0; player.xpNeed=12;
  player.shardsRun=0;

  player.corr=0;
  player.baseDmg=1; player.baseAtk=1; player.baseCrit=0.05; player.baseCritD=1.8;
  player.baseMove=1; player.baseLuck=0; player.baseMagnet=0;
  player.dmg=1; player.atkSpd=1; player.projSpd=1; player.range=1; player.move=1;
  player.crit=0.05; player.critDmg=1.8;
  player.armor=0; player.luck=0; player.magnet=0;
  player.upgrades={};
  for(const k in wcd) wcd[k]=0;

  // start weapon
  player.upgrades.pebble=1;

  buffFrenzy=0; buffDouble=0; magnetAll=0;
  chaosVac=false; vacTimer=10;

  streak=1.0; streakMeter=0; streakTimer=0;

  tRun=0; spawnAcc=0; doomSpawned=false;
  cam.shake=0; cam.slow=0;

  dmgWindow=0; dmgWinT=0.6; dpsEst=0;
  killsInWindow=0; killWinT=0.35;

  bossTimer=75; bossAlive=false;

  const ch=characters.find(c=>c.id===charId)||characters[0];
  ch.apply();

  showHint(`Blue = you. Red = enemies. Green = XP gems. Gold = powerups. Orange = chest.`, 4.2);
}

function startFromMenu(retry=false){
  audio.ensure();
  ui.menu.style.display="none";
  ui.death.style.display="none";
  ui.shop.style.display="none";

  const seedStr = retry ? (runSeed||ui.seedIn.value.trim()) : (ui.seedIn.value.trim() || ""+Math.floor(Math.random()*1e9));
  rng=new RNG(seedStr);
  runSeed=rng.seedStr;
  ui.seedTag.textContent=runSeed?("seed: "+runSeed):"";
  ui.seedIn.value=runSeed;

  resetRun(ui.charSel.value||"drifter");
  state="RUN";
}

function buildSummaryHTML(){
  const lines=[];
  lines.push(`<b>Damage:</b> ${player.dmg.toFixed(2)} · <b>Atk Spd:</b> ${player.atkSpd.toFixed(2)} · <b>Crit:</b> ${(player.crit*100).toFixed(0)}% · <b>Crit Dmg:</b> ${player.critDmg.toFixed(2)}x`);
  lines.push(`<b>Move:</b> ${player.move.toFixed(2)} · <b>Armor:</b> ${(player.armor + (player.upgrades.armor||0)).toFixed(0)} · <b>Luck:</b> ${(player.luck*100).toFixed(0)}%`);
  lines.push(`<b>Corruption:</b> ${player.corr|0} (enemy ramp x${corrMult().toFixed(2)})`);
  const w=[];
  for(const wd of weaponDefs){ const lvl=player.upgrades[wd.key]|0; if(lvl>0) w.push(`${wd.name} ${roman(lvl)}`); }
  lines.push(`<b>Weapons:</b> ${w.length?w.join(", "):"none"}`);
  const p=[];
  for(const pd of passiveDefs){ const lvl=player.upgrades[pd.key]|0; if(lvl>0) p.push(`${pd.name} ${roman(lvl)}`); }
  lines.push(`<b>Passives:</b> ${p.length?p.join(", "):"none"}`);
  return lines.join("<br>");
}

function endRun(){
  state="DEATH";
  ui.death.style.display="flex";

  const earned=Math.max(0, Math.floor(player.shardsRun*0.55 + player.lvl*0.9 + (tRun/28)));
  meta.shards += earned;
  saveMeta();

  ui.deathStats.textContent=`Survived ${formatTime(tRun)} · Level ${player.lvl} · Earned ${earned} shards · (Run shards: ${player.shardsRun})`;
  ui.deathBuild.innerHTML=buildSummaryHTML();

  addShake(18);
  audio.s_boss();
}

function goMenu(){
  state="MENU";
  ui.death.style.display="none";
  ui.shop.style.display="none";
  ui.menu.style.display="flex";
  saveMeta();
}

function pauseToggle(){
  if(state==="RUN"){
    state="PAUSE";
    showHint("Paused. Press <kbd>ESC</kbd> to resume.", 999);
  }else if(state==="PAUSE"){
    state="RUN";
    ui.hint.classList.remove("show");
    hintT=0;
  }
}

function toggleMute(){
  audio.ensure();
  audio.setMute(!audio.muted);
  ui.hudMute.textContent=audio.muted?"ON":"OFF";
  if(!audio.muted) audio.s_click();
}

/* ============================
   Loop (fixed timestep)
============================ */
let last=0, acc=0;
const FIXED=1/120;
const MAX_ACC=0.25;

function maybeKillSpike(){
  if(killsInWindow>=20){ cam.slow=0.12; killsInWindow=0; }
}
function slowmo(dt){ if(cam.slow>0){ cam.slow-=dt; return 0.55; } return 1.0; }

function step(dt){
  applyPassiveScaling();

  if(state!=="RUN"){
    hintStep(dt);
    updateHUD();
    draw();
    compactPools();
    return;
  }

  // chaos vacuum mutation
  if(chaosVac){
    vacTimer -= dt;
    if(vacTimer<=0){
      vacTimer=10;
      magnetAll=1.0;
      floatText(player.x,player.y-46,"VACUUM!", COLORS.gem, true);
      audio.s_power();
      addShake(8);
    }
  }

  updateStreak(dt);
  dash(dt);
  updatePlayer(dt);

  spawnStep(dt);

  rebuildGrid();
  fireWeapons(dt);

  collideBullets();
  updateBullets(dt);
  updateEnemies(dt);
  updateDrops(dt);
  updateGems(dt);

  updateParticles(dt);
  updateFloats(dt);

  killWinT -= dt;
  if(killWinT<=0){ killWinT=0.35; killsInWindow=0; }
  maybeKillSpike();

  dmgWinT -= dt;
  if(dmgWinT<=0){
    dpsEst = dmgWindow / 0.6;
    dmgWindow=0;
    dmgWinT=0.6;
  }

  hintStep(dt);
  updateHUD();
  draw();
  compactPools();
}

function loop(ts){
  if(!last) last=ts;
  let dt=(ts-last)/1000;
  last=ts;
  dt=clamp(dt,0,0.05);

  if(state==="PAUSE"||state==="MENU"||state==="ALTAR"||state==="DEATH"){
    step(0);
    requestAnimationFrame(loop);
    return;
  }

  dt *= slowmo(dt);
  acc = Math.min(MAX_ACC, acc+dt);
  while(acc>=FIXED){
    acc -= FIXED;
    tRun += FIXED;
    step(FIXED);
  }
  requestAnimationFrame(loop);
}

/* ============================
   GEM/POWERUP collision + weapon firing
============================ */
function updateGems(dt){ /* overwritten above - keep definition order */ }

/* ============================
   FIRE WEAPONS + openAltar on level
============================ */
function fireWeapons(dt){
  for(let i=0;i<weaponDefs.length;i++){
    const wd=weaponDefs[i];
    const lvl=player.upgrades[wd.key]|0;
    if(lvl>0) wd.fire(dt);
  }
}

/* ============================
   Overwrite updateGems (final)
============================ */
function updateGems(dt){
  const mag = player.magnet + 34;
  const mag2=(mag*DPR)*(mag*DPR);
  const global = magnetAll>0;

  for(let i=0;i<gems.length;i++){
    const g=gems[i]; if(!g.active) continue;
    let dx=player.x-g.x, dy=player.y-g.y;
    let d2=dx*dx+dy*dy;

    if(global || d2<mag2){
      const d=Math.sqrt(d2)||1;
      const pull=((global?2200:1200)*DPR/ZOOM_BASE) * (global?1:(1 - d/Math.sqrt(mag2))) * dt;
      g.vx += (dx/d)*pull;
      g.vy += (dy/d)*pull;
    }

    g.vx *= Math.pow(0.02, dt);
    g.vy *= Math.pow(0.02, dt);
    g.x += g.vx*dt;
    g.y += g.vy*dt;

    const rr=g.r+player.r;
    if(d2<=rr*rr){
      g.active=false;
      const xpGainBase=3 + g.val + (g.rare>=2?2:0);
      const xpGain=xpGainBase*streak;
      player.xp += xpGain;
      player.shardsRun += (g.val + (g.rare>=1?1:0));
      audio.s_pick();
      burst(player.x,player.y, 8, 140, "rgba(45,255,136,.55)", 1.0*DPR, 2.6*DPR, 0.10, 0.22);

      while(player.xp>=player.xpNeed){
        player.xp -= player.xpNeed;
        player.lvl++;
        player.xpNeed = Math.floor(player.xpNeed*1.18+2);
        openAltar();
        break;
      }
    }
  }
}

/* ============================
   Boot
============================ */
function boot(){
  resize();
  saveMeta();
  ui.hudMute.textContent=audio.muted?"ON":"OFF";
  refreshCharacterList();
  ui.menu.style.display="flex";
  ui.seedIn.value=""; ui.seedTag.textContent="";
  showHint(`Clarity pass: <b>Blue</b> player, <b>Red</b> enemies, <b>Green</b> XP, <b>Gold</b> powerups, <b>Orange</b> chests.`, 3.8);
  requestAnimationFrame(loop);
}
boot();

/* ============================
   Focus pause safety
============================ */
window.addEventListener("keydown",(e)=>{
  if(state==="ALTAR" && (e.code==="Digit1"||e.code==="Digit2"||e.code==="Digit3")) e.preventDefault();
});

/* ============================
   Menu buttons wiring (shop)
============================ */
function openShop(){ ui.menu.style.display="none"; ui.shop.style.display="flex"; renderShop(); }
function closeShop(){ ui.shop.style.display="none"; ui.menu.style.display="flex"; saveMeta(); }

})();
</script>
</body>
</html>
